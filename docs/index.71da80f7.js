var e,t,i={};Object.defineProperty(i,"__esModule",{value:!0}),i.serial=i.SerialPort=i.SerialPolyfillProtocol=void 0,(t=e=i.SerialPolyfillProtocol||(i.SerialPolyfillProtocol={}))[t.UsbCdcAcm=0]="UsbCdcAcm";const s=[16,8,7,6,5],n=[1,2],r=["none","even","odd"],a=["none","odd","even"],_=[1,1.5,2],o={protocol:e.UsbCdcAcm,usbControlInterfaceClass:2,usbTransferInterfaceClass:10};function c(e,t){const i=e.configurations[0];for(const e of i.interfaces){if(e.alternates[0].interfaceClass===t)return e}throw new TypeError(`Unable to find interface with class ${t}.`)}function T(e,t){const i=e.alternates[0];for(const e of i.endpoints)if(e.direction==t)return e;throw new TypeError(`Interface ${e.interfaceNumber} does not have an ${t} endpoint.`)}class d{constructor(e,t,i){this.type="bytes",this.device_=e,this.endpoint_=t,this.onError_=i}pull(e){(async()=>{var t;let i;if(e.desiredSize){const t=e.desiredSize/this.endpoint_.packetSize;i=Math.ceil(t)*this.endpoint_.packetSize}else i=this.endpoint_.packetSize;try{const s=await this.device_.transferIn(this.endpoint_.endpointNumber,i);if("ok"!=s.status&&(e.error(`USB error: ${s.status}`),this.onError_()),null===(t=s.data)||void 0===t?void 0:t.buffer){const t=new Uint8Array(s.data.buffer,s.data.byteOffset,s.data.byteLength);e.enqueue(t)}}catch(t){e.error(t.toString()),this.onError_()}})()}}class l{constructor(e,t,i){this.device_=e,this.endpoint_=t,this.onError_=i}async write(e,t){try{const i=await this.device_.transferOut(this.endpoint_.endpointNumber,e);"ok"!=i.status&&(t.error(i.status),this.onError_())}catch(e){t.error(e.toString()),this.onError_()}}}class I{constructor(e,t){this.polyfillOptions_=Object.assign(Object.assign({},o),t),this.outputSignals_={dataTerminalReady:!1,requestToSend:!1,break:!1},this.device_=e,this.controlInterface_=c(this.device_,this.polyfillOptions_.usbControlInterfaceClass),this.transferInterface_=c(this.device_,this.polyfillOptions_.usbTransferInterfaceClass),this.inEndpoint_=T(this.transferInterface_,"in"),this.outEndpoint_=T(this.transferInterface_,"out")}get readable(){var e;return!this.readable_&&this.device_.opened&&(this.readable_=new ReadableStream(new d(this.device_,this.inEndpoint_,(()=>{this.readable_=null})),{highWaterMark:null!==(e=this.serialOptions_.bufferSize)&&void 0!==e?e:255})),this.readable_}get writable(){var e;return!this.writable_&&this.device_.opened&&(this.writable_=new WritableStream(new l(this.device_,this.outEndpoint_,(()=>{this.writable_=null})),new ByteLengthQueuingStrategy({highWaterMark:null!==(e=this.serialOptions_.bufferSize)&&void 0!==e?e:255}))),this.writable_}async open(e){this.serialOptions_=e,this.validateOptions();try{await this.device_.open(),null===this.device_.configuration&&await this.device_.selectConfiguration(1),await this.device_.claimInterface(this.controlInterface_.interfaceNumber),this.controlInterface_!==this.transferInterface_&&await this.device_.claimInterface(this.transferInterface_.interfaceNumber),await this.setLineCoding(),await this.setSignals({dataTerminalReady:!0})}catch(e){throw this.device_.opened&&await this.device_.close(),new Error("Error setting up device: "+e.toString())}}async close(){const e=[];this.readable_&&e.push(this.readable_.cancel()),this.writable_&&e.push(this.writable_.abort()),await Promise.all(e),this.readable_=null,this.writable_=null,this.device_.opened&&(await this.setSignals({dataTerminalReady:!1,requestToSend:!1}),await this.device_.close())}async forget(){return this.device_.forget()}getInfo(){return{usbVendorId:this.device_.vendorId,usbProductId:this.device_.productId}}reconfigure(e){return this.serialOptions_=Object.assign(Object.assign({},this.serialOptions_),e),this.validateOptions(),this.setLineCoding()}async setSignals(e){if(this.outputSignals_=Object.assign(Object.assign({},this.outputSignals_),e),void 0!==e.dataTerminalReady||void 0!==e.requestToSend){const e=(this.outputSignals_.dataTerminalReady?1:0)|(this.outputSignals_.requestToSend?2:0);await this.device_.controlTransferOut({requestType:"class",recipient:"interface",request:34,value:e,index:this.controlInterface_.interfaceNumber})}if(void 0!==e.break){const e=this.outputSignals_.break?65535:0;await this.device_.controlTransferOut({requestType:"class",recipient:"interface",request:35,value:e,index:this.controlInterface_.interfaceNumber})}}validateOptions(){if(!this.isValidBaudRate(this.serialOptions_.baudRate))throw new RangeError("invalid Baud Rate "+this.serialOptions_.baudRate);if(!this.isValidDataBits(this.serialOptions_.dataBits))throw new RangeError("invalid dataBits "+this.serialOptions_.dataBits);if(!this.isValidStopBits(this.serialOptions_.stopBits))throw new RangeError("invalid stopBits "+this.serialOptions_.stopBits);if(!this.isValidParity(this.serialOptions_.parity))throw new RangeError("invalid parity "+this.serialOptions_.parity)}isValidBaudRate(e){return e%1==0}isValidDataBits(e){return void 0===e||s.includes(e)}isValidStopBits(e){return void 0===e||n.includes(e)}isValidParity(e){return void 0===e||r.includes(e)}async setLineCoding(){var e,t,i;const s=new ArrayBuffer(7),n=new DataView(s);n.setUint32(0,this.serialOptions_.baudRate,!0),n.setUint8(4,_.indexOf(null!==(e=this.serialOptions_.stopBits)&&void 0!==e?e:1)),n.setUint8(5,a.indexOf(null!==(t=this.serialOptions_.parity)&&void 0!==t?t:"none")),n.setUint8(6,null!==(i=this.serialOptions_.dataBits)&&void 0!==i?i:8);if("ok"!=(await this.device_.controlTransferOut({requestType:"class",recipient:"interface",request:32,value:0,index:this.controlInterface_.interfaceNumber},s)).status)throw new DOMException("NetworkError","Failed to set line coding.")}}i.SerialPort=I;i.serial=new class{async requestPort(e,t){t=Object.assign(Object.assign({},o),t);const i=[];if(e&&e.filters)for(const s of e.filters){const e={classCode:t.usbControlInterfaceClass};void 0!==s.usbVendorId&&(e.vendorId=s.usbVendorId),void 0!==s.usbProductId&&(e.productId=s.usbProductId),i.push(e)}0===i.length&&i.push({classCode:t.usbControlInterfaceClass});const s=await navigator.usb.requestDevice({filters:i});return new I(s,t)}async getPorts(e){e=Object.assign(Object.assign({},o),e);const t=await navigator.usb.getDevices(),i=[];return t.forEach((t=>{try{const s=new I(t,e);i.push(s)}catch(e){}})),i}};class S{#e=0;#t=1;#i=2;#s=3;#n=4;#r=5;#a=6;#_=7;#o=9;#c=10;#T=11;#d=12;#l=144;#I=0;#S=1;#u=2;#h=4;#E=8;#O=16;#D=32;#f=64;#v=1;#R=2;#p=3;#F=4;#b=0;#y=1;#g=2;#A=3;#B=this.#e;#w="vendor";#m=0;#M=1;#C=2;#L=3;#P={SIO:1,FT8U232AM:2,FT232BM:3,FT2232C:4,FT232RL:5,FT2232H:6,FT4232H:7,FT232H:8,FTX:9};#U={ftdi_sio_b300:0,ftdi_sio_b600:1,ftdi_sio_b1200:2,ftdi_sio_b2400:3,ftdi_sio_b4800:4,ftdi_sio_b9600:5,ftdi_sio_b19200:6,ftdi_sio_b38400:7,ftdi_sio_b57600:8,ftdi_sio_b115200:9};#N=this.#n;#q=0;#H=256;#k=512;#V=768;#Q=1024;#Y=0;#j=2048;#G=4096;#K=16384;#x=this.#t;#W=1;#X=this.#W<<8|1;#z=this.#W<<8|0;#$=2;#J=this.#$<<8|2;#Z=this.#$<<8|0;#ee=this.#i;#te=0;#ie=256;#se=512;#ne=1024;#re=this.#c;#ae=this.#o;#_e=this.#a;#oe=this.#r;#ce=16;#Te=32;#de=64;#le=128;#Ie=this.#T;#Se=0;#ue=32;#he=this.#d;#Ee=this.#l;#Oe=8;#De=10;#fe=16;#ve=32;#Re=64;#pe=128;#Fe=1;#be=2;#ye=4;#ge=8;#Ae=16;#Be=32;#we=64;#me=128;constructor(e){this.device=e,this.interfaceNumber=0,this.endpointIn=0,this.endpointOut=0,this.modemStatusByte=0,this.lineStatusByte=0,this.packetsReceived=0}connect(e,t){this.onReceive=e,this.onReceiveError=t;let i=()=>{this.device.transferIn(this.endpointIn,64).then((e=>{let t=new Uint8Array(e.data.buffer);if(t[0]!=this.modemStatusByte&&(this.modemStatusByte=t[0]),t[1]!=this.lineStatusByte&&(this.lineStatusByte=t[1]),t.length>2){let e=new Uint8Array(t.length-2);for(let i=2;i<t.length;i++)e[i-2]=t[i];e.find((e=>0!==e))&&this.onReceive(e)}else this.packetsReceived=this.packetsReceived+1;i()}),(e=>{this.onReceiveError(e)}))};return this.device.open().then((()=>{if(null===this.device.configuration)return this.device.selectConfiguration(1)})).then((()=>{this.device.configuration.interfaces.forEach((e=>{e.alternates.forEach((t=>{console.log(t),255==t.interfaceClass&&(this.interfaceNumber=e.interfaceNumber,t.endpoints.forEach((e=>{"out"==e.direction&&(this.endpointOut=e.endpointNumber),"in"==e.direction&&(this.endpointIn=e.endpointNumber)})))}))}))})).then((()=>this.device.claimInterface(this.interfaceNumber))).then((()=>this.device.selectAlternateInterface(this.interfaceNumber,0))).then((()=>{this.device.controlTransferOut({requestType:"vendor",recipient:"device",request:this.#s,value:this.getBaudDivisor(19200),index:this.getBaudBase()})})).then((()=>this.device.controlTransferIn({requestType:"vendor",recipient:"device",request:this.#re,value:0,index:0},1))).then((e=>{if(this.device.latencyTimer=new Uint8Array(e.data.buffer)[0],1!=this.device.latencyTimer)return this.device.controlTransferOut({requestType:"vendor",recipient:"device",request:this.#ae,value:1,index:0})})).then((e=>this.device.latencyTimer=this.device.controlTransferIn({requestType:"vendor",recipient:"device",request:this.#re,value:0,index:0},1))).then((e=>(this.device.latencyTimer=new Uint8Array(e.data.buffer)[0],console.log("Current Latency Timer: "),console.log(this.device.latencyTimer),i(),this.device)))}DIV_ROUND_CLOSEST(e,t){return e-1>0||t-1>0||e>0==t>0?(e+t/2)/t:(e-t/2)/t}getBaudBase(){return 48e6}getBaudDivisor(e){let t=this.getBaudBase();let i=0,s=this.DIV_ROUND_CLOSEST(t,2*e);return i=s>>3,i|=[0,3,2,4,1,5,6,7][7&s]<<14,1==i?i=0:16385==i&&(i=1),i}send(e){return this.device.transferOut(this.endpointOut,e)}disconnect(){this.device.close()}}class u{constructor(e){if(!("usb"in navigator))throw new Error("USB Support not available!");this.configuration=e||{overridePortSettings:!1,baudrate:9600,bits:8,stop:1,parity:!1,deviceFilters:[]},this.devices=[]}async getAvailablePorts(){return this.devices=await navigator.usb.getDevices(),this.devices.map((e=>new S(e)))}async requestNewPort(){try{let e=await navigator.usb.requestDevice({filters:this.configuration.deviceFilters||[]});return e in this.devices||this.devices.push(e),new S(e)}catch(e){throw new Error(e)}}}let h,E=null;document.getElementById("requestUSB").addEventListener("click",(async function(){const e=document.getElementById("outUSB");try{const t=await navigator.usb.requestDevice({filters:[]});e.innerHTML=["productName","deviceClass","deviceSubclass","deviceProtocol"].map((e=>e+": "+t[e])).join("\n")}catch(t){e.innerHTML=t.message}})),document.getElementById("requestSerial").addEventListener("click",(async function(){E&&(E(),E=null);const e=document.getElementById("outSerial");try{e.innerHTML="";let t=i.serial;navigator.serial&&(t=navigator.serial,e.innerHTML+="\nWeb Serial API supported. Polyfill not used.");const s=await t.requestPort();e.innerHTML=["usbVendorId","usbProductId"].map((e=>e+": "+s[e])).join("\n");const n=document.getElementById("serial-open"),r=document.getElementById("serialOpen");n.style.display="block";const a=async()=>{try{const t={baudRate:+document.getElementById("baudRate").value,dataBits:+document.getElementById("dataBits").value,stopBits:+document.getElementById("stopBits").value,parity:document.getElementById("parity").value};console.log(t),await s.open(t),e.innerHTML+="\nopened"}catch(t){e.innerHTML=t.message}};r.addEventListener("click",a),E=()=>{E&&E(),r.removeEventListener("click",a)}}catch(t){e.innerHTML=t.message}})),document.getElementById("requestFTDI").addEventListener("click",(async function(){const e=document.getElementById("outFTDI");try{e.innerHTML="";const t=new u({overridePortSettings:!0,baud:19200,bits:8,stop:1,parity:!1}),i=h=await t.requestNewPort();await i.connect((t=>{e.innerHTML+="Rec: "+t.join(", ")+"\n"}));let s=async()=>{e.innerHTML+="Send 1, 3, 0, 52, 0, 1, 197, 196\n";const t=new Uint8Array([1,3,0,52,0,1,197,196]);await i.send(t),setTimeout(s,5e3)};s()}catch(t){e.innerHTML=t.message}}));
//# sourceMappingURL=index.71da80f7.js.map
