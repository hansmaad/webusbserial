var e,t,i={};Object.defineProperty(i,"__esModule",{value:!0}),i.serial=i.SerialPort=i.SerialPolyfillProtocol=void 0,(t=e=i.SerialPolyfillProtocol||(i.SerialPolyfillProtocol={}))[t.UsbCdcAcm=0]="UsbCdcAcm";const s=[16,8,7,6,5],n=[1,2],a=["none","even","odd"],r=["none","odd","even"],o=[1,1.5,2],c={protocol:e.UsbCdcAcm,usbControlInterfaceClass:2,usbTransferInterfaceClass:10};function l(e,t){const i=e.configurations[0];for(const e of i.interfaces){if(e.alternates[0].interfaceClass===t)return e}throw new TypeError(`Unable to find interface with class ${t}.`)}function d(e,t){const i=e.alternates[0];for(const e of i.endpoints)if(e.direction==t)return e;throw new TypeError(`Interface ${e.interfaceNumber} does not have an ${t} endpoint.`)}class u{constructor(e,t,i){this.type="bytes",this.device_=e,this.endpoint_=t,this.onError_=i}pull(e){(async()=>{var t;let i;if(e.desiredSize){const t=e.desiredSize/this.endpoint_.packetSize;i=Math.ceil(t)*this.endpoint_.packetSize}else i=this.endpoint_.packetSize;try{const s=await this.device_.transferIn(this.endpoint_.endpointNumber,i);if("ok"!=s.status&&(e.error(`USB error: ${s.status}`),this.onError_()),null===(t=s.data)||void 0===t?void 0:t.buffer){const t=new Uint8Array(s.data.buffer,s.data.byteOffset,s.data.byteLength);e.enqueue(t)}}catch(t){e.error(t.toString()),this.onError_()}})()}}class h{constructor(e,t,i){this.device_=e,this.endpoint_=t,this.onError_=i}async write(e,t){try{const i=await this.device_.transferOut(this.endpoint_.endpointNumber,e);"ok"!=i.status&&(t.error(i.status),this.onError_())}catch(e){t.error(e.toString()),this.onError_()}}}class f{constructor(e,t){this.polyfillOptions_=Object.assign(Object.assign({},c),t),this.outputSignals_={dataTerminalReady:!1,requestToSend:!1,break:!1},this.device_=e,this.controlInterface_=l(this.device_,this.polyfillOptions_.usbControlInterfaceClass),this.transferInterface_=l(this.device_,this.polyfillOptions_.usbTransferInterfaceClass),this.inEndpoint_=d(this.transferInterface_,"in"),this.outEndpoint_=d(this.transferInterface_,"out")}get readable(){var e;return!this.readable_&&this.device_.opened&&(this.readable_=new ReadableStream(new u(this.device_,this.inEndpoint_,(()=>{this.readable_=null})),{highWaterMark:null!==(e=this.serialOptions_.bufferSize)&&void 0!==e?e:255})),this.readable_}get writable(){var e;return!this.writable_&&this.device_.opened&&(this.writable_=new WritableStream(new h(this.device_,this.outEndpoint_,(()=>{this.writable_=null})),new ByteLengthQueuingStrategy({highWaterMark:null!==(e=this.serialOptions_.bufferSize)&&void 0!==e?e:255}))),this.writable_}async open(e){this.serialOptions_=e,this.validateOptions();try{await this.device_.open(),null===this.device_.configuration&&await this.device_.selectConfiguration(1),await this.device_.claimInterface(this.controlInterface_.interfaceNumber),this.controlInterface_!==this.transferInterface_&&await this.device_.claimInterface(this.transferInterface_.interfaceNumber),await this.setLineCoding(),await this.setSignals({dataTerminalReady:!0})}catch(e){throw this.device_.opened&&await this.device_.close(),new Error("Error setting up device: "+e.toString())}}async close(){const e=[];this.readable_&&e.push(this.readable_.cancel()),this.writable_&&e.push(this.writable_.abort()),await Promise.all(e),this.readable_=null,this.writable_=null,this.device_.opened&&(await this.setSignals({dataTerminalReady:!1,requestToSend:!1}),await this.device_.close())}async forget(){return this.device_.forget()}getInfo(){return{usbVendorId:this.device_.vendorId,usbProductId:this.device_.productId}}reconfigure(e){return this.serialOptions_=Object.assign(Object.assign({},this.serialOptions_),e),this.validateOptions(),this.setLineCoding()}async setSignals(e){if(this.outputSignals_=Object.assign(Object.assign({},this.outputSignals_),e),void 0!==e.dataTerminalReady||void 0!==e.requestToSend){const e=(this.outputSignals_.dataTerminalReady?1:0)|(this.outputSignals_.requestToSend?2:0);await this.device_.controlTransferOut({requestType:"class",recipient:"interface",request:34,value:e,index:this.controlInterface_.interfaceNumber})}if(void 0!==e.break){const e=this.outputSignals_.break?65535:0;await this.device_.controlTransferOut({requestType:"class",recipient:"interface",request:35,value:e,index:this.controlInterface_.interfaceNumber})}}validateOptions(){if(!this.isValidBaudRate(this.serialOptions_.baudRate))throw new RangeError("invalid Baud Rate "+this.serialOptions_.baudRate);if(!this.isValidDataBits(this.serialOptions_.dataBits))throw new RangeError("invalid dataBits "+this.serialOptions_.dataBits);if(!this.isValidStopBits(this.serialOptions_.stopBits))throw new RangeError("invalid stopBits "+this.serialOptions_.stopBits);if(!this.isValidParity(this.serialOptions_.parity))throw new RangeError("invalid parity "+this.serialOptions_.parity)}isValidBaudRate(e){return e%1==0}isValidDataBits(e){return void 0===e||s.includes(e)}isValidStopBits(e){return void 0===e||n.includes(e)}isValidParity(e){return void 0===e||a.includes(e)}async setLineCoding(){var e,t,i;const s=new ArrayBuffer(7),n=new DataView(s);n.setUint32(0,this.serialOptions_.baudRate,!0),n.setUint8(4,o.indexOf(null!==(e=this.serialOptions_.stopBits)&&void 0!==e?e:1)),n.setUint8(5,r.indexOf(null!==(t=this.serialOptions_.parity)&&void 0!==t?t:"none")),n.setUint8(6,null!==(i=this.serialOptions_.dataBits)&&void 0!==i?i:8);if("ok"!=(await this.device_.controlTransferOut({requestType:"class",recipient:"interface",request:32,value:0,index:this.controlInterface_.interfaceNumber},s)).status)throw new DOMException("NetworkError","Failed to set line coding.")}}i.SerialPort=f;i.serial=new class{async requestPort(e,t){t=Object.assign(Object.assign({},c),t);const i=[];if(e&&e.filters)for(const s of e.filters){const e={classCode:t.usbControlInterfaceClass};void 0!==s.usbVendorId&&(e.vendorId=s.usbVendorId),void 0!==s.usbProductId&&(e.productId=s.usbProductId),i.push(e)}0===i.length&&i.push({classCode:t.usbControlInterfaceClass});const s=await navigator.usb.requestDevice({filters:i});return new f(s,t)}async getPorts(e){e=Object.assign(Object.assign({},c),e);const t=await navigator.usb.getDevices(),i=[];return t.forEach((t=>{try{const s=new f(t,e);i.push(s)}catch(e){}})),i}};let p=null;document.getElementById("requestUSB").addEventListener("click",(async function(){const e=document.getElementById("outUSB");try{const t=await navigator.usb.requestDevice({filters:[]});e.innerHTML=["productName","deviceClass","deviceSubclass","deviceProtocol"].map((e=>e+": "+t[e])).join("\n")}catch(t){e.innerHTML=t.message}})),document.getElementById("requestSerial").addEventListener("click",(async function(){p&&(p(),p=null);const e=document.getElementById("outSerial");try{e.innerHTML="";let t=i.serial;navigator.serial&&(t=navigator.serial,e.innerHTML+="\nWeb Serial API supported. Polyfill not used.");const s=await t.requestPort();e.innerHTML=["usbVendorId","usbProductId"].map((e=>e+": "+s[e])).join("\n");const n=document.getElementById("serial-open"),a=document.getElementById("serialOpen");n.style.display="block";const r=async()=>{try{const t={baudRate:+document.getElementById("baudRate").value,dataBits:+document.getElementById("dataBits").value,stopBits:+document.getElementById("stopBits").value,parity:document.getElementById("parity").value};console.log(t),await s.open(t),e.innerHTML+="\nopened"}catch(t){e.innerHTML=t.message}};a.addEventListener("click",r),p=()=>{p&&p(),a.removeEventListener("click",r)}}catch(t){e.innerHTML=t.message}}));
//# sourceMappingURL=index.f21db7a2.js.map
