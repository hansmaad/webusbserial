function t(t){return t&&t.__esModule?t.default:t}var e,i,s={};Object.defineProperty(s,"__esModule",{value:!0}),s.serial=s.SerialPort=s.SerialPolyfillProtocol=void 0,(i=e=s.SerialPolyfillProtocol||(s.SerialPolyfillProtocol={}))[i.UsbCdcAcm=0]="UsbCdcAcm";const n=[16,8,7,6,5],r=[1,2],a=["none","even","odd"],o=["none","odd","even"],c=[1,1.5,2],l={protocol:e.UsbCdcAcm,usbControlInterfaceClass:2,usbTransferInterfaceClass:10};function d(t,e){const i=t.configurations[0];for(const t of i.interfaces){if(t.alternates[0].interfaceClass===e)return t}throw new TypeError(`Unable to find interface with class ${e}.`)}function u(t,e){const i=t.alternates[0];for(const t of i.endpoints)if(t.direction==e)return t;throw new TypeError(`Interface ${t.interfaceNumber} does not have an ${e} endpoint.`)}class h{constructor(t,e,i){this.type="bytes",this.device_=t,this.endpoint_=e,this.onError_=i}pull(t){(async()=>{var e;let i;if(t.desiredSize){const e=t.desiredSize/this.endpoint_.packetSize;i=Math.ceil(e)*this.endpoint_.packetSize}else i=this.endpoint_.packetSize;try{const s=await this.device_.transferIn(this.endpoint_.endpointNumber,i);if("ok"!=s.status&&(t.error(`USB error: ${s.status}`),this.onError_()),null===(e=s.data)||void 0===e?void 0:e.buffer){const e=new Uint8Array(s.data.buffer,s.data.byteOffset,s.data.byteLength);t.enqueue(e)}}catch(e){t.error(e.toString()),this.onError_()}})()}}class f{constructor(t,e,i){this.device_=t,this.endpoint_=e,this.onError_=i}async write(t,e){try{const i=await this.device_.transferOut(this.endpoint_.endpointNumber,t);"ok"!=i.status&&(e.error(i.status),this.onError_())}catch(t){e.error(t.toString()),this.onError_()}}}class _{constructor(t,e){this.polyfillOptions_=Object.assign(Object.assign({},l),e),this.outputSignals_={dataTerminalReady:!1,requestToSend:!1,break:!1},this.device_=t,this.controlInterface_=d(this.device_,this.polyfillOptions_.usbControlInterfaceClass),this.transferInterface_=d(this.device_,this.polyfillOptions_.usbTransferInterfaceClass),this.inEndpoint_=u(this.transferInterface_,"in"),this.outEndpoint_=u(this.transferInterface_,"out")}get readable(){var t;return!this.readable_&&this.device_.opened&&(this.readable_=new ReadableStream(new h(this.device_,this.inEndpoint_,(()=>{this.readable_=null})),{highWaterMark:null!==(t=this.serialOptions_.bufferSize)&&void 0!==t?t:255})),this.readable_}get writable(){var t;return!this.writable_&&this.device_.opened&&(this.writable_=new WritableStream(new f(this.device_,this.outEndpoint_,(()=>{this.writable_=null})),new ByteLengthQueuingStrategy({highWaterMark:null!==(t=this.serialOptions_.bufferSize)&&void 0!==t?t:255}))),this.writable_}async open(t){this.serialOptions_=t,this.validateOptions();try{await this.device_.open(),null===this.device_.configuration&&await this.device_.selectConfiguration(1),await this.device_.claimInterface(this.controlInterface_.interfaceNumber),this.controlInterface_!==this.transferInterface_&&await this.device_.claimInterface(this.transferInterface_.interfaceNumber),await this.setLineCoding(),await this.setSignals({dataTerminalReady:!0})}catch(t){throw this.device_.opened&&await this.device_.close(),new Error("Error setting up device: "+t.toString())}}async close(){const t=[];this.readable_&&t.push(this.readable_.cancel()),this.writable_&&t.push(this.writable_.abort()),await Promise.all(t),this.readable_=null,this.writable_=null,this.device_.opened&&(await this.setSignals({dataTerminalReady:!1,requestToSend:!1}),await this.device_.close())}async forget(){return this.device_.forget()}getInfo(){return{usbVendorId:this.device_.vendorId,usbProductId:this.device_.productId}}reconfigure(t){return this.serialOptions_=Object.assign(Object.assign({},this.serialOptions_),t),this.validateOptions(),this.setLineCoding()}async setSignals(t){if(this.outputSignals_=Object.assign(Object.assign({},this.outputSignals_),t),void 0!==t.dataTerminalReady||void 0!==t.requestToSend){const t=(this.outputSignals_.dataTerminalReady?1:0)|(this.outputSignals_.requestToSend?2:0);await this.device_.controlTransferOut({requestType:"class",recipient:"interface",request:34,value:t,index:this.controlInterface_.interfaceNumber})}if(void 0!==t.break){const t=this.outputSignals_.break?65535:0;await this.device_.controlTransferOut({requestType:"class",recipient:"interface",request:35,value:t,index:this.controlInterface_.interfaceNumber})}}validateOptions(){if(!this.isValidBaudRate(this.serialOptions_.baudRate))throw new RangeError("invalid Baud Rate "+this.serialOptions_.baudRate);if(!this.isValidDataBits(this.serialOptions_.dataBits))throw new RangeError("invalid dataBits "+this.serialOptions_.dataBits);if(!this.isValidStopBits(this.serialOptions_.stopBits))throw new RangeError("invalid stopBits "+this.serialOptions_.stopBits);if(!this.isValidParity(this.serialOptions_.parity))throw new RangeError("invalid parity "+this.serialOptions_.parity)}isValidBaudRate(t){return t%1==0}isValidDataBits(t){return void 0===t||n.includes(t)}isValidStopBits(t){return void 0===t||r.includes(t)}isValidParity(t){return void 0===t||a.includes(t)}async setLineCoding(){var t,e,i;const s=new ArrayBuffer(7),n=new DataView(s);n.setUint32(0,this.serialOptions_.baudRate,!0),n.setUint8(4,c.indexOf(null!==(t=this.serialOptions_.stopBits)&&void 0!==t?t:1)),n.setUint8(5,o.indexOf(null!==(e=this.serialOptions_.parity)&&void 0!==e?e:"none")),n.setUint8(6,null!==(i=this.serialOptions_.dataBits)&&void 0!==i?i:8);if("ok"!=(await this.device_.controlTransferOut({requestType:"class",recipient:"interface",request:32,value:0,index:this.controlInterface_.interfaceNumber},s)).status)throw new DOMException("NetworkError","Failed to set line coding.")}}s.SerialPort=_;s.serial=new class{async requestPort(t,e){e=Object.assign(Object.assign({},l),e);const i=[];if(t&&t.filters)for(const s of t.filters){const t={classCode:e.usbControlInterfaceClass};void 0!==s.usbVendorId&&(t.vendorId=s.usbVendorId),void 0!==s.usbProductId&&(t.productId=s.usbProductId),i.push(t)}0===i.length&&i.push({classCode:e.usbControlInterfaceClass});const s=await navigator.usb.requestDevice({filters:i});return new _(s,e)}async getPorts(t){t=Object.assign(Object.assign({},l),t);const e=await navigator.usb.getDevices(),i=[];return e.forEach((e=>{try{const s=new _(e,t);i.push(s)}catch(t){}})),i}},document.getElementById("requestUSB").addEventListener("click",(async function(){const t=document.getElementById("outUSB");try{const e=await navigator.usb.requestDevice({filters:[]});t.innerHTML=["productName","deviceClass","deviceSubclass","deviceProtocol"].map((t=>t+": "+e[t])).join("\n")}catch(e){t.innerHTML=e.message}})),document.getElementById("requestSerial").addEventListener("click",(async function(){const e=document.getElementById("outSerial");try{e.innerHTML="";let i=t(s);navigator.serial&&(i=navigator.serial,e.innerHTML+="\nWeb Serial API supported. Polyfill not used.");const n=await i.requestPort();e.innerHTML=["usbVendorId","usbProductId"].map((t=>t+": "+n[t])).join("\n")}catch(t){e.innerHTML=t.message}}));
//# sourceMappingURL=index.7521ec44.js.map
