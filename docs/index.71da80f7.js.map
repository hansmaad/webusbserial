{"mappings":"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","sources":["node_modules/web-serial-polyfill/serial.ts","src/ftdi.js","src/index.js"],"sourcesContent":["/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of\n * the License at\n *\n *    https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in\n * writing, software distributed under the License is\n * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES\n * OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing\n * permissions and limitations under the License.\n */\n'use strict';\n\nexport enum SerialPolyfillProtocol {\n  UsbCdcAcm, // eslint-disable-line no-unused-vars\n}\n\nexport interface SerialPolyfillOptions {\n  protocol?: SerialPolyfillProtocol;\n  usbControlInterfaceClass?: number;\n  usbTransferInterfaceClass?: number;\n}\n\nconst kSetLineCoding = 0x20;\nconst kSetControlLineState = 0x22;\nconst kSendBreak = 0x23;\n\nconst kDefaultBufferSize = 255;\nconst kDefaultDataBits = 8;\nconst kDefaultParity = 'none';\nconst kDefaultStopBits = 1;\n\nconst kAcceptableDataBits = [16, 8, 7, 6, 5];\nconst kAcceptableStopBits = [1, 2];\nconst kAcceptableParity = ['none', 'even', 'odd'];\n\nconst kParityIndexMapping: ParityType[] =\n    ['none', 'odd', 'even'];\nconst kStopBitsIndexMapping = [1, 1.5, 2];\n\nconst kDefaultPolyfillOptions = {\n  protocol: SerialPolyfillProtocol.UsbCdcAcm,\n  usbControlInterfaceClass: 2,\n  usbTransferInterfaceClass: 10,\n};\n\n/**\n * Utility function to get the interface implementing a desired class.\n * @param {USBDevice} device The USB device.\n * @param {number} classCode The desired interface class.\n * @return {USBInterface} The first interface found that implements the desired\n * class.\n * @throws TypeError if no interface is found.\n */\nfunction findInterface(device: USBDevice, classCode: number): USBInterface {\n  const configuration = device.configurations[0];\n  for (const iface of configuration.interfaces) {\n    const alternate = iface.alternates[0];\n    if (alternate.interfaceClass === classCode) {\n      return iface;\n    }\n  }\n  throw new TypeError(`Unable to find interface with class ${classCode}.`);\n}\n\n/**\n * Utility function to get an endpoint with a particular direction.\n * @param {USBInterface} iface The interface to search.\n * @param {USBDirection} direction The desired transfer direction.\n * @return {USBEndpoint} The first endpoint with the desired transfer direction.\n * @throws TypeError if no endpoint is found.\n */\nfunction findEndpoint(iface: USBInterface, direction: USBDirection):\n    USBEndpoint {\n  const alternate = iface.alternates[0];\n  for (const endpoint of alternate.endpoints) {\n    if (endpoint.direction == direction) {\n      return endpoint;\n    }\n  }\n  throw new TypeError(`Interface ${iface.interfaceNumber} does not have an ` +\n                      `${direction} endpoint.`);\n}\n\n/**\n * Implementation of the underlying source API[1] which reads data from a USB\n * endpoint. This can be used to construct a ReadableStream.\n *\n * [1]: https://streams.spec.whatwg.org/#underlying-source-api\n */\nclass UsbEndpointUnderlyingSource implements UnderlyingByteSource {\n  private device_: USBDevice;\n  private endpoint_: USBEndpoint;\n  private onError_: () => void;\n\n  type: 'bytes';\n\n  /**\n   * Constructs a new UnderlyingSource that will pull data from the specified\n   * endpoint on the given USB device.\n   *\n   * @param {USBDevice} device\n   * @param {USBEndpoint} endpoint\n   * @param {function} onError function to be called on error\n   */\n  constructor(device: USBDevice, endpoint: USBEndpoint, onError: () => void) {\n    this.type = 'bytes';\n    this.device_ = device;\n    this.endpoint_ = endpoint;\n    this.onError_ = onError;\n  }\n\n  /**\n   * Reads a chunk of data from the device.\n   *\n   * @param {ReadableByteStreamController} controller\n   */\n  pull(controller: ReadableByteStreamController): void {\n    (async (): Promise<void> => {\n      let chunkSize;\n      if (controller.desiredSize) {\n        const d = controller.desiredSize / this.endpoint_.packetSize;\n        chunkSize = Math.ceil(d) * this.endpoint_.packetSize;\n      } else {\n        chunkSize = this.endpoint_.packetSize;\n      }\n\n      try {\n        const result = await this.device_.transferIn(\n            this.endpoint_.endpointNumber, chunkSize);\n        if (result.status != 'ok') {\n          controller.error(`USB error: ${result.status}`);\n          this.onError_();\n        }\n        if (result.data?.buffer) {\n          const chunk = new Uint8Array(\n              result.data.buffer, result.data.byteOffset,\n              result.data.byteLength);\n          controller.enqueue(chunk);\n        }\n      } catch (error) {\n        controller.error(error.toString());\n        this.onError_();\n      }\n    })();\n  }\n}\n\n/**\n * Implementation of the underlying sink API[2] which writes data to a USB\n * endpoint. This can be used to construct a WritableStream.\n *\n * [2]: https://streams.spec.whatwg.org/#underlying-sink-api\n */\nclass UsbEndpointUnderlyingSink implements UnderlyingSink<Uint8Array> {\n  private device_: USBDevice;\n  private endpoint_: USBEndpoint;\n  private onError_: () => void;\n\n  /**\n   * Constructs a new UnderlyingSink that will write data to the specified\n   * endpoint on the given USB device.\n   *\n   * @param {USBDevice} device\n   * @param {USBEndpoint} endpoint\n   * @param {function} onError function to be called on error\n   */\n  constructor(device: USBDevice, endpoint: USBEndpoint, onError: () => void) {\n    this.device_ = device;\n    this.endpoint_ = endpoint;\n    this.onError_ = onError;\n  }\n\n  /**\n   * Writes a chunk to the device.\n   *\n   * @param {Uint8Array} chunk\n   * @param {WritableStreamDefaultController} controller\n   */\n  async write(\n      chunk: Uint8Array,\n      controller: WritableStreamDefaultController): Promise<void> {\n    try {\n      const result =\n          await this.device_.transferOut(this.endpoint_.endpointNumber, chunk);\n      if (result.status != 'ok') {\n        controller.error(result.status);\n        this.onError_();\n      }\n    } catch (error) {\n      controller.error(error.toString());\n      this.onError_();\n    }\n  }\n}\n\n/** a class used to control serial devices over WebUSB */\nexport class SerialPort {\n  private polyfillOptions_: SerialPolyfillOptions;\n  private device_: USBDevice;\n  private controlInterface_: USBInterface;\n  private transferInterface_: USBInterface;\n  private inEndpoint_: USBEndpoint;\n  private outEndpoint_: USBEndpoint;\n\n  private serialOptions_: SerialOptions;\n  private readable_: ReadableStream<Uint8Array> | null;\n  private writable_: WritableStream<Uint8Array> | null;\n  private outputSignals_: SerialOutputSignals;\n\n  /**\n   * constructor taking a WebUSB device that creates a SerialPort instance.\n   * @param {USBDevice} device A device acquired from the WebUSB API\n   * @param {SerialPolyfillOptions} polyfillOptions Optional options to\n   * configure the polyfill.\n   */\n  public constructor(\n      device: USBDevice,\n      polyfillOptions?: SerialPolyfillOptions) {\n    this.polyfillOptions_ = {...kDefaultPolyfillOptions, ...polyfillOptions};\n    this.outputSignals_ = {\n      dataTerminalReady: false,\n      requestToSend: false,\n      break: false,\n    };\n\n    this.device_ = device;\n    this.controlInterface_ = findInterface(\n        this.device_,\n        this.polyfillOptions_.usbControlInterfaceClass as number);\n    this.transferInterface_ = findInterface(\n        this.device_,\n        this.polyfillOptions_.usbTransferInterfaceClass as number);\n    this.inEndpoint_ = findEndpoint(this.transferInterface_, 'in');\n    this.outEndpoint_ = findEndpoint(this.transferInterface_, 'out');\n  }\n\n  /**\n   * Getter for the readable attribute. Constructs a new ReadableStream as\n   * necessary.\n   * @return {ReadableStream} the current readable stream\n   */\n  public get readable(): ReadableStream<Uint8Array> | null {\n    if (!this.readable_ && this.device_.opened) {\n      this.readable_ = new ReadableStream<Uint8Array>(\n          new UsbEndpointUnderlyingSource(\n              this.device_, this.inEndpoint_, () => {\n                this.readable_ = null;\n              }),\n          {\n            highWaterMark: this.serialOptions_.bufferSize ?? kDefaultBufferSize,\n          });\n    }\n    return this.readable_;\n  }\n\n  /**\n   * Getter for the writable attribute. Constructs a new WritableStream as\n   * necessary.\n   * @return {WritableStream} the current writable stream\n   */\n  public get writable(): WritableStream<Uint8Array> | null {\n    if (!this.writable_ && this.device_.opened) {\n      this.writable_ = new WritableStream(\n          new UsbEndpointUnderlyingSink(\n              this.device_, this.outEndpoint_, () => {\n                this.writable_ = null;\n              }),\n          new ByteLengthQueuingStrategy({\n            highWaterMark: this.serialOptions_.bufferSize ?? kDefaultBufferSize,\n          }));\n    }\n    return this.writable_;\n  }\n\n  /**\n   * a function that opens the device and claims all interfaces needed to\n   * control and communicate to and from the serial device\n   * @param {SerialOptions} options Object containing serial options\n   * @return {Promise<void>} A promise that will resolve when device is ready\n   * for communication\n   */\n  public async open(options: SerialOptions): Promise<void> {\n    this.serialOptions_ = options;\n    this.validateOptions();\n\n    try {\n      await this.device_.open();\n      if (this.device_.configuration === null) {\n        await this.device_.selectConfiguration(1);\n      }\n\n      await this.device_.claimInterface(this.controlInterface_.interfaceNumber);\n      if (this.controlInterface_ !== this.transferInterface_) {\n        await this.device_.claimInterface(\n            this.transferInterface_.interfaceNumber);\n      }\n\n      await this.setLineCoding();\n      await this.setSignals({dataTerminalReady: true});\n    } catch (error) {\n      if (this.device_.opened) {\n        await this.device_.close();\n      }\n      throw new Error('Error setting up device: ' + error.toString());\n    }\n  }\n\n  /**\n   * Closes the port.\n   *\n   * @return {Promise<void>} A promise that will resolve when the port is\n   * closed.\n   */\n  public async close(): Promise<void> {\n    const promises = [];\n    if (this.readable_) {\n      promises.push(this.readable_.cancel());\n    }\n    if (this.writable_) {\n      promises.push(this.writable_.abort());\n    }\n    await Promise.all(promises);\n    this.readable_ = null;\n    this.writable_ = null;\n    if (this.device_.opened) {\n      await this.setSignals({dataTerminalReady: false, requestToSend: false});\n      await this.device_.close();\n    }\n  }\n\n  /**\n   * Forgets the port.\n   *\n   * @return {Promise<void>} A promise that will resolve when the port is\n   * forgotten.\n   */\n  public async forget(): Promise<void> {\n    return this.device_.forget();\n  }\n\n  /**\n   * A function that returns properties of the device.\n   * @return {SerialPortInfo} Device properties.\n   */\n  public getInfo(): SerialPortInfo {\n    return {\n      usbVendorId: this.device_.vendorId,\n      usbProductId: this.device_.productId,\n    };\n  }\n\n  /**\n   * A function used to change the serial settings of the device\n   * @param {object} options the object which carries serial settings data\n   * @return {Promise<void>} A promise that will resolve when the options are\n   * set\n   */\n  public reconfigure(options: SerialOptions): Promise<void> {\n    this.serialOptions_ = {...this.serialOptions_, ...options};\n    this.validateOptions();\n    return this.setLineCoding();\n  }\n\n  /**\n   * Sets control signal state for the port.\n   * @param {SerialOutputSignals} signals The signals to enable or disable.\n   * @return {Promise<void>} a promise that is resolved when the signal state\n   * has been changed.\n   */\n  public async setSignals(signals: SerialOutputSignals): Promise<void> {\n    this.outputSignals_ = {...this.outputSignals_, ...signals};\n\n    if (signals.dataTerminalReady !== undefined ||\n        signals.requestToSend !== undefined) {\n      // The Set_Control_Line_State command expects a bitmap containing the\n      // values of all output signals that should be enabled or disabled.\n      //\n      // Ref: USB CDC specification version 1.1 §6.2.14.\n      const value = (this.outputSignals_.dataTerminalReady ? 1 << 0 : 0) |\n                    (this.outputSignals_.requestToSend ? 1 << 1 : 0);\n\n      await this.device_.controlTransferOut({\n        'requestType': 'class',\n        'recipient': 'interface',\n        'request': kSetControlLineState,\n        'value': value,\n        'index': this.controlInterface_.interfaceNumber,\n      });\n    }\n\n    if (signals.break !== undefined) {\n      // The SendBreak command expects to be given a duration for how long the\n      // break signal should be asserted. Passing 0xFFFF enables the signal\n      // until 0x0000 is send.\n      //\n      // Ref: USB CDC specification version 1.1 §6.2.15.\n      const value = this.outputSignals_.break ? 0xFFFF : 0x0000;\n\n      await this.device_.controlTransferOut({\n        'requestType': 'class',\n        'recipient': 'interface',\n        'request': kSendBreak,\n        'value': value,\n        'index': this.controlInterface_.interfaceNumber,\n      });\n    }\n  }\n\n  /**\n   * Checks the serial options for validity and throws an error if it is\n   * not valid\n   */\n  private validateOptions(): void {\n    if (!this.isValidBaudRate(this.serialOptions_.baudRate)) {\n      throw new RangeError('invalid Baud Rate ' + this.serialOptions_.baudRate);\n    }\n\n    if (!this.isValidDataBits(this.serialOptions_.dataBits)) {\n      throw new RangeError('invalid dataBits ' + this.serialOptions_.dataBits);\n    }\n\n    if (!this.isValidStopBits(this.serialOptions_.stopBits)) {\n      throw new RangeError('invalid stopBits ' + this.serialOptions_.stopBits);\n    }\n\n    if (!this.isValidParity(this.serialOptions_.parity)) {\n      throw new RangeError('invalid parity ' + this.serialOptions_.parity);\n    }\n  }\n\n  /**\n   * Checks the baud rate for validity\n   * @param {number} baudRate the baud rate to check\n   * @return {boolean} A boolean that reflects whether the baud rate is valid\n   */\n  private isValidBaudRate(baudRate: number): boolean {\n    return baudRate % 1 === 0;\n  }\n\n  /**\n   * Checks the data bits for validity\n   * @param {number} dataBits the data bits to check\n   * @return {boolean} A boolean that reflects whether the data bits setting is\n   * valid\n   */\n  private isValidDataBits(dataBits: number | undefined): boolean {\n    if (typeof dataBits === 'undefined') {\n      return true;\n    }\n    return kAcceptableDataBits.includes(dataBits);\n  }\n\n  /**\n   * Checks the stop bits for validity\n   * @param {number} stopBits the stop bits to check\n   * @return {boolean} A boolean that reflects whether the stop bits setting is\n   * valid\n   */\n  private isValidStopBits(stopBits: number | undefined): boolean {\n    if (typeof stopBits === 'undefined') {\n      return true;\n    }\n    return kAcceptableStopBits.includes(stopBits);\n  }\n\n  /**\n   * Checks the parity for validity\n   * @param {string} parity the parity to check\n   * @return {boolean} A boolean that reflects whether the parity is valid\n   */\n  private isValidParity(parity: ParityType | undefined): boolean {\n    if (typeof parity === 'undefined') {\n      return true;\n    }\n    return kAcceptableParity.includes(parity);\n  }\n\n  /**\n   * sends the options alog the control interface to set them on the device\n   * @return {Promise} a promise that will resolve when the options are set\n   */\n  private async setLineCoding(): Promise<void> {\n    // Ref: USB CDC specification version 1.1 §6.2.12.\n    const buffer = new ArrayBuffer(7);\n    const view = new DataView(buffer);\n    view.setUint32(0, this.serialOptions_.baudRate, true);\n    view.setUint8(\n        4, kStopBitsIndexMapping.indexOf(\n            this.serialOptions_.stopBits ?? kDefaultStopBits));\n    view.setUint8(\n        5, kParityIndexMapping.indexOf(\n            this.serialOptions_.parity ?? kDefaultParity));\n    view.setUint8(6, this.serialOptions_.dataBits ?? kDefaultDataBits);\n\n    const result = await this.device_.controlTransferOut({\n      'requestType': 'class',\n      'recipient': 'interface',\n      'request': kSetLineCoding,\n      'value': 0x00,\n      'index': this.controlInterface_.interfaceNumber,\n    }, buffer);\n    if (result.status != 'ok') {\n      throw new DOMException('NetworkError', 'Failed to set line coding.');\n    }\n  }\n}\n\n/** implementation of the global navigator.serial object */\nclass Serial {\n  /**\n   * Requests permission to access a new port.\n   *\n   * @param {SerialPortRequestOptions} options\n   * @param {SerialPolyfillOptions} polyfillOptions\n   * @return {Promise<SerialPort>}\n   */\n  async requestPort(\n      options?: SerialPortRequestOptions,\n      polyfillOptions?: SerialPolyfillOptions): Promise<SerialPort> {\n    polyfillOptions = {...kDefaultPolyfillOptions, ...polyfillOptions};\n\n    const usbFilters: USBDeviceFilter[] = [];\n    if (options && options.filters) {\n      for (const filter of options.filters) {\n        const usbFilter: USBDeviceFilter = {\n          classCode: polyfillOptions.usbControlInterfaceClass,\n        };\n        if (filter.usbVendorId !== undefined) {\n          usbFilter.vendorId = filter.usbVendorId;\n        }\n        if (filter.usbProductId !== undefined) {\n          usbFilter.productId = filter.usbProductId;\n        }\n        usbFilters.push(usbFilter);\n      }\n    }\n\n    if (usbFilters.length === 0) {\n      usbFilters.push({\n        classCode: polyfillOptions.usbControlInterfaceClass,\n      });\n    }\n\n    const device = await navigator.usb.requestDevice({'filters': usbFilters});\n    const port = new SerialPort(device, polyfillOptions);\n    return port;\n  }\n\n  /**\n   * Get the set of currently available ports.\n   *\n   * @param {SerialPolyfillOptions} polyfillOptions Polyfill configuration that\n   * should be applied to these ports.\n   * @return {Promise<SerialPort[]>} a promise that is resolved with a list of\n   * ports.\n   */\n  async getPorts(polyfillOptions?: SerialPolyfillOptions):\n      Promise<SerialPort[]> {\n    polyfillOptions = {...kDefaultPolyfillOptions, ...polyfillOptions};\n\n    const devices = await navigator.usb.getDevices();\n    const ports: SerialPort[] = [];\n    devices.forEach((device) => {\n      try {\n        const port = new SerialPort(device, polyfillOptions);\n        ports.push(port);\n      } catch (e) {\n        // Skip unrecognized port.\n      }\n    });\n    return ports;\n  }\n}\n\n/* an object to be used for starting the serial workflow */\nexport const serial = new Serial();\n","/*\r\n\tWebUSB FTDI Driver v0.01a\r\n\t(C) 2020 Shaped Technologies (Jai B.)\r\n\r\n\tGPL v2 free for personal use / commercial or closed source use requires commercial license - contact us.\r\n\r\n\tThis wouldn't have been possible without the Linux driver, so shoutout to the developers of that!\r\n\r\n\tData Transfer Efficiency / Bulk Transfers Technical Note\r\n\thttps://www.ftdichip.com/Support/Documents/TechnicalNotes/TN_103_FTDI_USB_Data_Transfer_Efficiency(FT_000097).pdf\r\n\r\n\tChipset feature comparison:\r\n\thttps://www.ftdichip.com/Support/Documents/TechnicalNotes/TN_107%20FTDI_Chipset_Feature_Comparison.pdf\r\n\r\n\thttps://www.ftdichip.com/Support/Documents/AppNotes/AN232B-04_DataLatencyFlow.pdf\r\n\r\n*/\r\n\r\n/*\r\n\r\nUSB_SETUP_HOST_TO_DEVICE\t0x00\tTransfer direction: host to device\r\nUSB_SETUP_DEVICE_TO_HOST\t0x80\tTransfer direction: device to host\r\nUSB_SETUP_TYPE_STANDARD\t\t0x00\tType: standard\r\nUSB_SETUP_TYPE_CLASS\t\t0x20\tType: class\r\nUSB_SETUP_TYPE_VENDOR\t\t0x40\tType: vendor\r\nUSB_SETUP_RECIPIENT_DEVICE\t0x00\tRecipient: device\r\nUSB_SETUP_RECIPIENT_INTERFACE\t0x01\tRecipient: interface\r\nUSB_SETUP_RECIPIENT_ENDPOINT\t0x02\tRecipient: endpoint\r\nUSB_SETUP_RECIPIENT_OTHER\t0x03\tRecipient: other\r\n\r\n*/\r\n\r\nclass WebUSBSerialPort {\r\n\t/* Commands */\r\n\t#FTDI_SIO_RESET \t\t\t\t= 0x00; /* Reset the port */\r\n\t#FTDI_SIO_MODEM_CTRL\t\t\t= 0x01; /* Set the modem control register */\r\n\t#FTDI_SIO_SET_FLOW_CTRL \t\t= 0x02; /* Set flow control register */\r\n\t#FTDI_SIO_SET_BAUD_RATE \t\t= 0x03; /* Set baud rate */\r\n\t#FTDI_SIO_SET_DATA\t\t\t\t= 0x04; /* Set the data characteristics of the port */\r\n\t#FTDI_SIO_GET_MODEM_STATUS\t\t= 0x05; /* Retrieve current value of modem status register */\r\n\t#FTDI_SIO_SET_EVENT_CHAR\t\t= 0x06; /* Set the event character */\r\n\t#FTDI_SIO_SET_ERROR_CHAR\t\t= 0x07; /* Set the error character */\r\n\t#FTDI_SIO_SET_LATENCY_TIMER\t\t= 0x09; /* Set the latency timer */\r\n\t#FTDI_SIO_GET_LATENCY_TIMER \t= 0x0a; /* Get the latency timer */\r\n\t#FTDI_SIO_SET_BITMODE\t\t\t= 0x0b; /* Set bitbang mode */\r\n\t#FTDI_SIO_READ_PINS\t\t\t\t= 0x0c; /* Read immediate value of pins */\r\n\t#FTDI_SIO_READ_EEPROM\t\t\t= 0x90; /* Read EEPROM */\r\n\r\n\t/* not in linux driver? */\r\n\t#FTDI_BitMode_Reset       = 0x00;\r\n\t#FTDI_BitMode_BitBang     = 0x01;\r\n\t#FTDI_BitMode_MPSSE       = 0x02;\r\n\t#FTDI_BitMode_SyncBitBang = 0x04;\r\n\t#FTDI_BitMode_MCU         = 0x08;\r\n\t#FTDI_BitMode_Opto        = 0x10;\r\n\t#FTDI_BitMode_CBus        = 0x20;\r\n\t#FTDI_BitMode_SyncFIFO    = 0x40;\r\n\r\n\t/* Interface indices for FT2232, FT2232H and FT4232H devices */\r\n\t#INTERFACE_A\t\t= 1;\r\n\t#INTERFACE_B\t\t= 2;\r\n\t#INTERFACE_C\t\t= 3;\r\n\t#INTERFACE_D\t\t= 4;\r\n\r\n\t/* Port Identifier Table */\r\n\t#PIT_DEFAULT\t\t= 0; /* SIOA */\r\n\t#PIT_SIOA\t\t\t= 1; /* SIOA */\r\n\r\n\t/* The device this driver is tested with one has only one port */\r\n\t#PIT_SIOB\t\t\t= 2; /* SIOB */\r\n\t#PIT_PARALLEL\t\t= 3; /* Parallel */\r\n\r\n\t/* FTDI_SIO_RESET \r\n\t BmRequestType:  0100 0000B\r\n\t bRequest:       FTDI_SIO_RESET\r\n\t wValue:         Control Value\r\n\t                   0 = Reset SIO\r\n\t                   1 = Purge RX buffer\r\n\t                   2 = Purge TX buffer\r\n\t wIndex:         Port\r\n\t wLength:        0\r\n\t Data:           None\r\n\t\r\n\t The Reset SIO command has this effect:\r\n\t\r\n\t    Sets flow control set to 'none'\r\n\t    Event char = $0D\r\n\t    Event trigger = disabled\r\n\t    Purge RX buffer\r\n\t    Purge TX buffer\r\n\t    Clear DTR\r\n\t    Clear RTS\r\n\t    baud and data format not reset\r\n\t\r\n\t The Purge RX and TX buffer commands affect nothing except the buffers\r\n\t\r\n\t*/\r\n\t#FTDI_SIO_RESET_REQUEST \t= this.#FTDI_SIO_RESET;\r\n\t#FTDI_SIO_RESET_REQUEST_TYPE = 'vendor';\r\n\t#FTDI_SIO_RESET_SIO \t\t= 0;\r\n\t#FTDI_SIO_RESET_PURGE_RX \t= 1;\r\n\t#FTDI_SIO_RESET_PURGE_TX \t= 2;\r\n\r\n\t/* FTDI_SIO_SET_BAUDRATE */\r\n\t#FTDI_SIO_SET_BAUDRATE_REQUEST \t\t= 0x03;\r\n\r\n\r\n\t#ftdi_chip_type = {\r\n\t\tSIO : 1,\r\n\t\tFT8U232AM : 2,\r\n\t\tFT232BM : 3,\r\n\t\tFT2232C : 4,\r\n\t\tFT232RL : 5,\r\n\t\tFT2232H : 6,\r\n\t\tFT4232H : 7,\r\n\t\tFT232H  : 8,\r\n\t\tFTX     : 9\r\n\t};\r\n\r\n\t/*\r\n\t  BmRequestType:  0100 0000B\r\n\t  bRequest:       FTDI_SIO_SET_BAUDRATE\r\n\t  wValue:         BaudDivisor value - see below\r\n\t  wIndex:         Port\r\n\t  wLength:        0\r\n\t  Data:           None\r\n\t  The BaudDivisor values are calculated as follows:\r\n\t  - BaseClock is either 12000000 or 48000000 depending on the device.\r\n\t    FIXME: I wish I knew how to detect old chips to select proper base clock!\r\n\t  - BaudDivisor is a fixed point number encoded in a funny way.\r\n\t    (--WRONG WAY OF THINKING--)\r\n\t    BaudDivisor is a fixed point number encoded with following bit weighs:\r\n\t    (-2)(-1)(13..0). It is a radical with a denominator of 4, so values\r\n\t    end with 0.0 (00...), 0.25 (10...), 0.5 (01...), and 0.75 (11...).\r\n\t    (--THE REALITY--)\r\n\t    The both-bits-set has quite different meaning from 0.75 - the chip\r\n\t    designers have decided it to mean 0.125 instead of 0.75.\r\n\t    This info looked up in FTDI application note \"FT8U232 DEVICES \\ Data Rates\r\n\t    and Flow Control Consideration for USB to RS232\".\r\n\t  - BaudDivisor = (BaseClock / 16) / BaudRate, where the (=) operation should\r\n\t    automagically re-encode the resulting value to take fractions into\r\n\t    consideration.\r\n\t  As all values are integers, some bit twiddling is in order:\r\n\t    BaudDivisor = (BaseClock / 16 / BaudRate) |\r\n\t    (((BaseClock / 2 / BaudRate) & 4) ? 0x4000    // 0.5\r\n\t     : ((BaseClock / 2 / BaudRate) & 2) ? 0x8000  // 0.25\r\n\t     : ((BaseClock / 2 / BaudRate) & 1) ? 0xc000  // 0.125\r\n\t     : 0)\r\n\t \r\n\t  For the FT232BM, a 17th divisor bit was introduced to encode the multiples\r\n\t  of 0.125 missing from the FT8U232AM.  Bits 16 to 14 are coded as follows\r\n\t  (the first four codes are the same as for the FT8U232AM, where bit 16 is\r\n\t  always 0):\r\n\t    000 - add .000 to divisor\r\n\t    001 - add .500 to divisor\r\n\t    010 - add .250 to divisor\r\n\t    011 - add .125 to divisor\r\n\t    100 - add .375 to divisor\r\n\t    101 - add .625 to divisor\r\n\t    110 - add .750 to divisor\r\n\t    111 - add .875 to divisor\r\n\t  Bits 15 to 0 of the 17-bit divisor are placed in the urb value.  Bit 16 is\r\n\t  placed in bit 0 of the urb index.\r\n\t \r\n\t  Note that there are a couple of special cases to support the highest baud\r\n\t  rates.  If the calculated divisor value is 1, this needs to be replaced with\r\n\t  0.  Additionally for the FT232BM, if the calculated divisor value is 0x4001\r\n\t  (1.5), this needs to be replaced with 0x0001 (1) (but this divisor value is\r\n\t  not supported by the FT8U232AM).\r\n\t */\r\n\t#ftdi_sio_baudrate = {\r\n\t\tftdi_sio_b300 : 0,\r\n\t\tftdi_sio_b600 : 1,\r\n\t\tftdi_sio_b1200 : 2,\r\n\t\tftdi_sio_b2400 : 3,\r\n\t\tftdi_sio_b4800 : 4,\r\n\t\tftdi_sio_b9600 : 5,\r\n\t\tftdi_sio_b19200 : 6,\r\n\t\tftdi_sio_b38400 : 7,\r\n\t\tftdi_sio_b57600 : 8,\r\n\t\tftdi_sio_b115200 : 9\r\n\t};\r\n\r\n\t/* FTDI_SIO_SET_DATA \r\n\t  BmRequestType:  0100 0000B\r\n\t  bRequest:       FTDI_SIO_SET_DATA\r\n\t  wValue:         Data characteristics (see below)\r\n\t  wIndex:         Port\r\n\t  wLength:        0\r\n\t  Data:           No\r\n\t \r\n\t  Data characteristics\r\n\t \r\n\t    B0..7   Number of data bits\r\n\t    B8..10  Parity\r\n\t            0 = None\r\n\t            1 = Odd\r\n\t            2 = Even\r\n\t            3 = Mark\r\n\t            4 = Space\r\n\t    B11..13 Stop Bits\r\n\t            0 = 1\r\n\t            1 = 1.5\r\n\t            2 = 2\r\n\t    B14\r\n\t            1 = TX ON (break)\r\n\t            0 = TX OFF (normal state)\r\n\t    B15 Reserved\r\n\t \r\n\t */\r\n\t#FTDI_SIO_SET_DATA_REQUEST\t= this.#FTDI_SIO_SET_DATA;\r\n\t#FTDI_SIO_SET_DATA_PARITY_NONE\t= (0x0 << 8);\r\n\t#FTDI_SIO_SET_DATA_PARITY_ODD\t= (0x1 << 8);\r\n\t#FTDI_SIO_SET_DATA_PARITY_EVEN\t= (0x2 << 8);\r\n\t#FTDI_SIO_SET_DATA_PARITY_MARK\t= (0x3 << 8);\r\n\t#FTDI_SIO_SET_DATA_PARITY_SPACE\t= (0x4 << 8);\r\n\t#FTDI_SIO_SET_DATA_STOP_BITS_1\t= (0x0 << 11);\r\n\t#FTDI_SIO_SET_DATA_STOP_BITS_15\t= (0x1 << 11);\r\n\t#FTDI_SIO_SET_DATA_STOP_BITS_2\t= (0x2 << 11);\r\n\t#FTDI_SIO_SET_BREAK\t\t\t\t= (0x1 << 14);\r\n\r\n\t/* FTDI_SIO_MODEM_CTRL \r\n\r\n\t  BmRequestType:   0100 0000B\r\n\t  bRequest:        FTDI_SIO_MODEM_CTRL\r\n\t  wValue:          ControlValue (see below)\r\n\t  wIndex:          Port\r\n\t  wLength:         0\r\n\t  Data:            None\r\n\t \r\n\t  NOTE: If the device is in RTS/CTS flow control, the RTS set by this\r\n\t  command will be IGNORED without an error being returned\r\n\t  Also - you can not set DTR and RTS with one control message\r\n\t */\t\r\n\t#FTDI_SIO_SET_MODEM_CTRL_REQUEST \t\t= this.#FTDI_SIO_MODEM_CTRL;\r\n\r\n\t/*\r\n\t ControlValue\r\n\t B0    DTR state\r\n\t          0 = reset\r\n\t          1 = set\r\n\t B1    RTS state\r\n\t          0 = reset\r\n\t          1 = set\r\n\t B2..7 Reserved\r\n\t B8    DTR state enable\r\n\t          0 = ignore\r\n\t          1 = use DTR state\r\n\t B9    RTS state enable\r\n\t          0 = ignore\r\n\t          1 = use RTS state\r\n\t B10..15 Reserved\r\n\t*/\r\n\r\n\t#FTDI_SIO_SET_DTR_MASK = 0x1;\r\n\t#FTDI_SIO_SET_DTR_HIGH = ((this.#FTDI_SIO_SET_DTR_MASK  << 8) | 1);\r\n\t#FTDI_SIO_SET_DTR_LOW  = ((this.#FTDI_SIO_SET_DTR_MASK  << 8) | 0);\r\n\t#FTDI_SIO_SET_RTS_MASK = 0x2;\r\n\t#FTDI_SIO_SET_RTS_HIGH = ((this.#FTDI_SIO_SET_RTS_MASK << 8) | 2);\r\n\t#FTDI_SIO_SET_RTS_LOW  = ((this.#FTDI_SIO_SET_RTS_MASK << 8) | 0);\r\n\r\n\t/* FTDI_SIO_SET_FLOW_CTRL \r\n\t   BmRequestType:  0100 0000b\r\n\t   bRequest:       FTDI_SIO_SET_FLOW_CTRL\r\n\t   wValue:         Xoff/Xon\r\n\t   wIndex:         Protocol/Port - hIndex is protocol / lIndex is port\r\n\t   wLength:        0\r\n\t   Data:           None\r\n\t\r\n\t hIndex protocol is:\r\n\t   B0 Output handshaking using RTS/CTS\r\n\t       0 = disabled\r\n\t       1 = enabled\r\n\t   B1 Output handshaking using DTR/DSR\r\n\t       0 = disabled\r\n\t       1 = enabled\r\n\t   B2 Xon/Xoff handshaking\r\n\t       0 = disabled\r\n\t       1 = enabled\r\n\t\r\n\t A value of zero in the hIndex field disables handshaking\r\n\t\r\n\t If Xon/Xoff handshaking is specified, the hValue field should contain the\r\n\t XOFF character and the lValue field contains the XON character.\r\n\t */\r\n\t#FTDI_SIO_SET_FLOW_CTRL_REQUEST = this.#FTDI_SIO_SET_FLOW_CTRL;\r\n\t#FTDI_SIO_DISABLE_FLOW_CTRL = 0x0;\r\n\t#FTDI_SIO_RTS_CTS_HS = (0x1 << 8);\r\n\t#FTDI_SIO_DTR_DSR_HS = (0x2 << 8);\r\n\t#FTDI_SIO_XON_XOFF_HS = (0x4 << 8);\r\n\r\n\t/*\r\n\t FTDI_SIO_GET_LATENCY_TIMER\r\n\t\r\n\t Set the timeout interval. The FTDI collects data from the\r\n\t device, transmitting it to the host when either A) 62 bytes are\r\n\t received, or B) the timeout interval has elapsed and the buffer\r\n\t contains at least 1 byte.  Setting this value to a small number\r\n\t can dramatically improve performance for applications which send\r\n\t small packets, since the default value is 16ms.\r\n\r\n\t  BmRequestType:   1100 0000b\r\n\t  bRequest:        FTDI_SIO_GET_LATENCY_TIMER\r\n\t  wValue:          0\r\n\t  wIndex:          Port\r\n\t  wLength:         0\r\n\t  Data:            latency (on return)\r\n\t */\r\n\t#FTDI_SIO_GET_LATENCY_TIMER_REQUEST = this.#FTDI_SIO_GET_LATENCY_TIMER;\r\n\r\n\t/*\r\n\t FTDI_SIO_SET_LATENCY_TIMER\r\n\r\n\t Set the timeout interval. The FTDI collects data from the\r\n\t device, transmitting it to the host when either A) 62 bytes are\r\n\t received, or B) the timeout interval has elapsed and the buffer\r\n\t contains at least 1 byte.  Setting this value to a small number\r\n\t can dramatically improve performance for applications which send\r\n\t small packets, since the default value is 16ms.\r\n\r\n\t  BmRequestType:   0100 0000b\r\n\t  bRequest:        FTDI_SIO_SET_LATENCY_TIMER\r\n\t  wValue:          Latency (milliseconds)\r\n\t  wIndex:          Port\r\n\t  wLength:         0\r\n\t  Data:            None\r\n\r\n\t wValue:\r\n\t   B0..7   Latency timer\r\n\t   B8..15  0\r\n\r\n\t*/\r\n\t#FTDI_SIO_SET_LATENCY_TIMER_REQUEST = this.#FTDI_SIO_SET_LATENCY_TIMER;\r\n\r\n\r\n\t/*\r\n\t FTDI_SIO_SET_EVENT_CHAR\r\n\t\r\n\t Set the special event character for the specified communications port.\r\n\t If the device sees this character it will immediately return the\r\n\t data read so far - rather than wait 40ms or until 62 bytes are read\r\n\t which is what normally happens.\r\n\r\n\t  BmRequestType:   0100 0000b\r\n\t  bRequest:        FTDI_SIO_SET_EVENT_CHAR\r\n\t  wValue:          EventChar\r\n\t  wIndex:          Port\r\n\t  wLength:         0\r\n\t  Data:            None\r\n\t\r\n\t wValue:\r\n\t   B0..7   Event Character\r\n\t   B8      Event Character Processing\r\n\t             0 = disabled\r\n\t             1 = enabled\r\n\t   B9..15  Reserved\r\n\t\r\n\t FTDI_SIO_SET_ERROR_CHAR \r\n\t Set the parity error replacement character for the specified communications\r\n\t port\r\n\t  BmRequestType:  0100 0000b\r\n\t  bRequest:       FTDI_SIO_SET_EVENT_CHAR\r\n\t  wValue:         Error Char\r\n\t  wIndex:         Port\r\n\t  wLength:        0\r\n\t  Data:           None\r\n\t\r\n\tError Char\r\n\t  B0..7  Error Character\r\n\t  B8     Error Character Processing\r\n\t           0 = disabled\r\n\t           1 = enabled\r\n\t  B9..15 Reserved\r\n\t\r\n\t */\r\n\r\n\t#FTDI_SIO_SET_EVENT_CHAR_REQUEST = this.#FTDI_SIO_SET_EVENT_CHAR;\r\n\r\n\r\n\t/* FTDI_SIO_GET_MODEM_STATUS \r\n\t Retrieve the current value of the modem status register \r\n\t   BmRequestType:   1100 0000b\r\n\t   bRequest:        FTDI_SIO_GET_MODEM_STATUS\r\n\t   wValue:          zero\r\n\t   wIndex:          Port\r\n\t   wLength:         1\r\n\t   Data:            Status\r\n\t\r\n\t One byte of data is returned\r\n\t B0..3 0\r\n\t B4    CTS\r\n\t         0 = inactive\r\n\t         1 = active\r\n\t B5    DSR\r\n\t         0 = inactive\r\n\t         1 = active\r\n\t B6    Ring Indicator (RI)\r\n\t         0 = inactive\r\n\t         1 = active\r\n\t B7    Receive Line Signal Detect (RLSD)\r\n\t         0 = inactive\r\n\t         1 = active\r\n\t */\r\n\r\n\t#FTDI_SIO_GET_MODEM_STATUS_REQUEST = this.#FTDI_SIO_GET_MODEM_STATUS;\r\n\t#FTDI_SIO_CTS_MASK \t= 0x10;\r\n\t#FTDI_SIO_DSR_MASK \t= 0x20;\r\n\t#FTDI_SIO_RI_MASK  \t= 0x40;\r\n\t#FTDI_SIO_RLSD_MASK = 0x80;\r\n\r\n\t/* FTDI_SIO_SET_BITMODE */\r\n\t#FTDI_SIO_SET_BITMODE_REQUEST = this.#FTDI_SIO_SET_BITMODE;\r\n\r\n\t/* Possible bitmodes for FTDI_SIO_SET_BITMODE_REQUEST */\r\n\t#FTDI_SIO_BITMODE_RESET\t\t= 0x00;\r\n\t#FTDI_SIO_BITMODE_CBUS\t\t= 0x20;\r\n\r\n\t/* FTDI_SIO_READ_PINS */\r\n\t#FTDI_SIO_READ_PINS_REQUEST = this.#FTDI_SIO_READ_PINS;\r\n\r\n\t/*\r\n\t * FTDI_SIO_READ_EEPROM\r\n\t *\r\n\t * EEPROM format found in FTDI AN_201, \"FT-X MTP memory Configuration\",\r\n\t * http://www.ftdichip.com/Support/Documents/AppNotes/AN_201_FT-X%20MTP%20Memory%20Configuration.pdf\r\n\t */\r\n\t#FTDI_SIO_READ_EEPROM_REQUEST = this.#FTDI_SIO_READ_EEPROM;\r\n\r\n\t#FTDI_FTX_CBUS_MUX_GPIO\t = 0x8;\r\n\t#FTDI_FT232R_CBUS_MUX_GPIO = 0xa;\r\n\r\n\t/* Descriptors returned by the device\r\n\t\r\n\t  Device Descriptor\r\n\t\r\n\t Offset\tField\t\t\tSize\tValue\tDescription\r\n\t 0\t\tbLength\t\t\t1\t\t0x12\tSize of descriptor in bytes\r\n\t 1\t\tbDescriptorType\t1\t\t0x01\tDEVICE Descriptor Type\r\n\t 2\t\tbcdUSB\t\t\t2\t\t0x0110\tUSB Spec Release Number\r\n\t 4\t\tbDeviceClass\t1\t\t0x00\tClass Code\r\n\t 5\t\tbDeviceSubClass\t1\t\t0x00\tSubClass Code\r\n\t 6\t\tbDeviceProtocol\t1\t\t0x00\tProtocol Code\r\n\t 7\t\tbMaxPacketSize0 1\t\t0x08\tMaximum packet size for endpoint 0\r\n\t 8\t\tidVendor\t\t2\t\t0x0403\tVendor ID\r\n\t 10\t\tidProduct\t\t2\t\t0x8372\tProduct ID (FTDI_SIO_PID)\r\n\t 12\t\tbcdDevice\t\t2\t\t0x0001\tDevice release number\r\n\t 14\t\tiManufacturer\t1\t\t0x01\tIndex of man. string desc\r\n\t 15\t\tiProduct\t\t1\t\t0x02\tIndex of prod string desc\r\n\t 16\t\tiSerialNumber\t1\t\t0x02\tIndex of serial nmr string desc\r\n\t 17\t\tbNumConfigurations 1    0x01\tNumber of possible configurations\r\n\t\r\n\t Configuration Descriptor\r\n\t\r\n\t Offset\tField\t\t\tSize\tValue\r\n\t 0\tbLength\t\t\t1\t0x09\tSize of descriptor in bytes\r\n\t 1\tbDescriptorType\t\t1\t0x02\tCONFIGURATION Descriptor Type\r\n\t 2\twTotalLength\t\t2\t0x0020\tTotal length of data\r\n\t 4\tbNumInterfaces\t\t1\t0x01\tNumber of interfaces supported\r\n\t 5\tbConfigurationValue\t1\t0x01\tArgument for SetCOnfiguration() req\r\n\t 6\tiConfiguration\t\t1\t0x02\tIndex of config string descriptor\r\n\t 7\tbmAttributes\t\t1\t0x20\tConfig characteristics Remote Wakeup\r\n\t 8\tMaxPower\t\t1\t0x1E\tMax power consumption\r\n\t\r\n\t Interface Descriptor\r\n\t\r\n\t Offset\tField\t\t\tSize\tValue\r\n\t 0\tbLength\t\t\t1\t0x09\tSize of descriptor in bytes\r\n\t 1\tbDescriptorType\t\t1\t0x04\tINTERFACE Descriptor Type\r\n\t 2\tbInterfaceNumber\t1\t0x00\tNumber of interface\r\n\t 3\tbAlternateSetting\t1\t0x00\tValue used to select alternate\r\n\t 4\tbNumEndpoints\t\t1\t0x02\tNumber of endpoints\r\n\t 5\tbInterfaceClass\t\t1\t0xFF\tClass Code\r\n\t 6\tbInterfaceSubClass\t1\t0xFF\tSubclass Code\r\n\t 7\tbInterfaceProtocol\t1\t0xFF\tProtocol Code\r\n\t 8\tiInterface\t\t1\t0x02\tIndex of interface string description\r\n\t\r\n\t IN Endpoint Descriptor\r\n\t\r\n\t Offset\tField\t\t\tSize\tValue\r\n\t 0\tbLength\t\t\t1\t0x07\tSize of descriptor in bytes\r\n\t 1\tbDescriptorType\t\t1\t0x05\tENDPOINT descriptor type\r\n\t 2\tbEndpointAddress\t1\t0x82\tAddress of endpoint\r\n\t 3\tbmAttributes\t\t1\t0x02\tEndpoint attributes - Bulk\r\n\t 4\tbNumEndpoints\t\t2\t0x0040\tmaximum packet size\r\n\t 5\tbInterval\t\t1\t0x00\tInterval for polling endpoint\r\n\t\r\n\t OUT Endpoint Descriptor\r\n\t\r\n\t Offset\tField\t\t\tSize\tValue\r\n\t 0\tbLength\t\t\t1\t0x07\tSize of descriptor in bytes\r\n\t 1\tbDescriptorType\t\t1\t0x05\tENDPOINT descriptor type\r\n\t 2\tbEndpointAddress\t1\t0x02\tAddress of endpoint\r\n\t 3\tbmAttributes\t\t1\t0x02\tEndpoint attributes - Bulk\r\n\t 4\tbNumEndpoints\t\t2\t0x0040\tmaximum packet size\r\n\t 5\tbInterval\t\t1\t0x00\tInterval for polling endpoint\r\n\t\r\n\t DATA FORMAT\r\n\t\r\n\t IN Endpoint\r\n\t\r\n\t The device reserves the first two bytes of data on this endpoint to contain\r\n\t the current values of the modem and line status registers. In the absence of\r\n\t data, the device generates a message consisting of these two status bytes\r\n\t every 40 ms *** (maybe 16ms for newer/higher clkd dev?)\r\n\r\n\t *** According to TN103:\r\n\r\n   \tFTDI devices will return data to the host in 2 cases:\r\n   \t •The IC has a full buffer of data to send back to the host. (64 bytes minus 2 status bytes)\r\n   \t •The latency timer has expired. (default 16ms on windows driver; don't konw if this is device default)\r\n   \t \t- 16ms latency timer fucks with ISR (maybe others?) datalogging normally with HTS\r\n\r\n\tThe latency timer acts as a timeout on the receive buffer which will trigger the transmission\r\n\tof any data in the chip’s receive buffer back to the host. \r\n\r\n\tThe latency timer acts as a timeout on the receive buffer which will trigger the transmission\r\n\tof any data in the chip’s receive buffer back to the host.  In cases when the amount of data\r\n\tbeing received is minimal, this prevents applications from having to wait a long time for a\r\n\tfull packet.\r\n\r\n\tIf the receive buffer of the chip is empty when the latency timer expires, 2 status\r\n\tbytes are returned which contain the modem status and line status of the UART.  For FT245\r\n\tdevices, these bytes are still returned but have no meaning. If the latency timer is expiring\r\n\tbefore the receive buffer is full, short USB packets will be returned to the host.  As this is\r\n\tnot the most efficient packet size, this may be unsuitable for some applications. \r\n\r\n\tFor example, a UART receiving data at 9600 baud with a default latency timer value (16ms) will\r\n\tgenerate USB packets of around 16 bytes before the latency timer expires and transmits the\r\n\tdata available back to the PC.  If 64 byte IN packets were desired to minimise the number of\r\n\tINs required to complete a read,the packet size could be increased by increasing the value of\r\n\tthe latency timer.  In this case, a value greater than 64ms would be sufficient for the chip to\r\n\ttransmit full USB packets back to the host assuming data was constantly being received by the\r\n\tUART.\r\n\r\n\tIn the case of FTDI’s USB-UART devices, the IN packet size may appear to be dependent\r\n\ton baud rate.  This is not the case: it is simply that the UART may receive data faster at a\r\n\thigher baud rate and thus has a better chance of filling the buffer before the latency\r\n\ttimer expires\r\n\r\n\tWhen optimising data throughput for FTDI devices, the following factors should be considered:\r\n\t\t•Send as much data to the IC from the host application as possible in a single write.\r\n\t\tThis will maximise the size of the data packets being sent to the device and hence minimise\r\n\t\tthe number of packets required and time to transfer an amount of data.\r\n\r\n\t\t•Set the latency timer to a value appropriate for the application.  Note that a low latency\r\n\t\ttimer value may result in many short incoming USB packets rather than a single large packet,\r\n\t\tthus diminishing performance\r\n\r\n\t Byte 0: Modem Status\r\n\t\r\n\t Offset\tDescription\r\n\t B0\tReserved - must be 1\r\n\t B1\tReserved - must be 0\r\n\t B2\tReserved - must be 0\r\n\t B3\tReserved - must be 0\r\n\t B4\tClear to Send (CTS)\r\n\t B5\tData Set Ready (DSR)\r\n\t B6\tRing Indicator (RI)\r\n\t B7\tReceive Line Signal Detect (RLSD)\r\n\t\r\n\t Byte 1: Line Status\r\n\t\r\n\t Offset\tDescription\r\n\t B0\tData Ready (DR)\r\n\t B1\tOverrun Error (OE)\r\n\t B2\tParity Error (PE)\r\n\t B3\tFraming Error (FE)\r\n\t B4\tBreak Interrupt (BI)\r\n\t B5\tTransmitter Holding Register (THRE)\r\n\t B6\tTransmitter Empty (TEMT)\r\n\t B7\tError in RCVR FIFO\r\n\t\r\n\t */\r\n\t#FTDI_RS0_CTS\t=\t(1 << 4);\r\n\t#FTDI_RS0_DSR\t=\t(1 << 5);\r\n\t#FTDI_RS0_RI\t=\t(1 << 6);\r\n\t#FTDI_RS0_RLSD\t=\t(1 << 7);\r\n\r\n\t#FTDI_RS_DR \t=\t1;\r\n\t#FTDI_RS_OE \t=\t(1 << 1);\r\n\t#FTDI_RS_PE \t=\t(1 << 2);\r\n\t#FTDI_RS_FE \t=\t(1 << 3);\r\n\t#FTDI_RS_BI \t=\t(1 << 4);\r\n\t#FTDI_RS_THRE\t=\t(1 << 5);\r\n\t#FTDI_RS_TEMT\t=\t(1 << 6);\r\n\t#FTDI_RS_FIFO\t=\t(1 << 7);\r\n\r\n\t/*\r\n\t * OUT Endpoint\r\n\t *\r\n\t * This device reserves the first bytes of data on this endpoint contain the\r\n\t * length and port identifier of the message. For the FTDI USB Serial converter\r\n\t * the port identifier is always 1.\r\n\t *\r\n\t * Byte 0: Line Status\r\n\t *\r\n\t * Offset\tDescription\r\n\t * B0\tReserved - must be 1\r\n\t * B1\tReserved - must be 0\r\n\t * B2..7\tLength of message - (not including Byte 0)\r\n\t *\r\n\t */\r\n\r\n    // device: any;\r\n\r\n    // interfaceNumber = 0;\r\n    // endpointIn = 0;\r\n    // endpointOut = 0;\r\n    // modemStatusByte = 0;\r\n    // lineStatusByte = 0;\r\n    // packetsReceived = 0;\r\n    // onReceive = (a) => {};\r\n    // onReceiveError = (a) => {};\r\n\r\n\tconstructor(device) {\r\n\t\tthis.device = device;\r\n\r\n\t\tthis.interfaceNumber = 0;\r\n\t\tthis.endpointIn = 0;\r\n\t\tthis.endpointOut = 0;\r\n\r\n\t\tthis.modemStatusByte = 0;\r\n\t\tthis.lineStatusByte = 0;\r\n\r\n\t\tthis.packetsReceived = 0;\r\n\t}\r\n\r\n\tconnect(receiveCallback, errorCallback) {\r\n\t\tthis.onReceive = receiveCallback;\r\n\t\tthis.onReceiveError = errorCallback;\r\n\r\n\t\tlet readLoop = () => {\r\n\t\t  this.device.transferIn(this.endpointIn, 64).then(result => {\r\n\t\t  \t//console.log(\"Modem Status Byte:\"+this.result.data[0])\r\n\t\t  \t//console.log(\"Line Status Byte:\"+this.result.data[1])\r\n\t\t  \tlet resultArray = new Uint8Array(result.data.buffer);\r\n\r\n\t\t  \tif (resultArray[0] != this.modemStatusByte)\r\n\t\t  \t\tthis.modemStatusByte = resultArray[0];\r\n\r\n\t\t  \tif (resultArray[1] != this.lineStatusByte)\r\n\t\t  \t\tthis.lineStatusByte = resultArray[1];\r\n\r\n\t\t  \tif (resultArray.length > 2) {\r\n\t\t  \t\tlet dataArray = new Uint8Array(resultArray.length - 2);\r\n\t\t  \t\tfor (let x=2;x<resultArray.length;x++) {\r\n\t\t  \t\t\tdataArray[x - 2] = resultArray[x];\r\n\t\t  \t\t}\r\n\t\t\t\tif (dataArray.find(x => x !== 0)) {\r\n\t\t\t\t\tthis.onReceive(dataArray);\r\n\t\t\t\t}\r\n\t\t    \t\r\n\t\t  \t} else {\r\n\t\t  \t\tthis.packetsReceived = this.packetsReceived + 1;\r\n\t\t  \t}\r\n\t\t    \r\n\t\t    readLoop();\r\n\r\n\t\t  }, error => {\r\n\t\t    this.onReceiveError(error);\r\n\t\t  });\r\n\t\t};\r\n\r\n\t\treturn this.device.open()\r\n\t\t    .then(() => {\r\n\r\n\t\t      if (this.device.configuration === null) {\r\n\t\t        return this.device.selectConfiguration(1);\r\n\t\t      }\r\n\t\t    })\r\n\t\t    .then(() => {\r\n\t\t      var interfaces = this.device.configuration.interfaces;\r\n\t\t      /*console.log(\"interfaces:\")\r\n\t\t      console.log(interfaces)*/\r\n\t\t      interfaces.forEach(element => {\r\n\t\t        element.alternates.forEach(elementalt => {\r\n\t\t        \tconsole.log(elementalt);\r\n\t\t          if (elementalt.interfaceClass==0xFF) {\r\n\t\t            this.interfaceNumber = element.interfaceNumber;\r\n\t\t            elementalt.endpoints.forEach(elementendpoint => {\r\n\t\t              if (elementendpoint.direction == \"out\") {\r\n\t\t                this.endpointOut = elementendpoint.endpointNumber;\r\n\t\t              }\r\n\t\t              if (elementendpoint.direction==\"in\") {\r\n\t\t                this.endpointIn = elementendpoint.endpointNumber;\r\n\t\t              }\r\n\t\t            })\r\n\t\t          }\r\n\t\t        })\r\n\t\t      })\r\n\t\t      /*console.log(\"in out\");\r\n\t\t      console.log(this.endpointIn)\r\n\t\t      console.log(this.endpointOut)*/\r\n\t\t    })\r\n\t\t    .then(() => this.device.claimInterface(this.interfaceNumber))\r\n\t\t    .then(() => this.device.selectAlternateInterface(this.interfaceNumber, 0))\r\n\t\t    .then(() => {\r\n\r\n\t\t    \t// let baud = 921600;\r\n\t\t\t\t// let baud = 9600;\r\n\t\t\t\tlet baud = 19200;\r\n\r\n/*\t\t    \tconsole.log(\"controlTransfer out now for \" + this.interfaceNumber)\r\n\t\t    \tconsole.log(\"req: \" + this.#FTDI_SIO_SET_BAUD_RATE)\r\n\t\t    \tconsole.log(\"val: \" + this.getBaudDivisor(baud) + '(' + baud + ')')\r\n\t\t    \tconsole.log(\"ind: \" + this.getBaudBase())*/\r\n\r\n\t\t\t\tthis.device.controlTransferOut({\r\n\t\t\t\t    requestType: 'vendor',\r\n\t\t\t\t    recipient: \"device\",\r\n\t\t\t\t    request: this.#FTDI_SIO_SET_BAUD_RATE,\r\n\t\t\t\t    value: this.getBaudDivisor(baud), // divisor_value\r\n\t\t\t\t    index: this.getBaudBase() // divisor_index\r\n\t\t\t\t});\r\n\t\t\t})\r\n\t\t\t.then(() => {\r\n\r\n\t\t\t\treturn this.device.controlTransferIn({\r\n\t\t\t\t\trequestType: 'vendor',\r\n\t\t\t\t\trecipient: 'device',\r\n\t\t\t\t\trequest: this.#FTDI_SIO_GET_LATENCY_TIMER_REQUEST,\r\n\t\t\t\t\tvalue: 0,\r\n\t\t\t\t\tindex: 0\r\n\t\t\t\t},1);\r\n\r\n\t\t\t})\r\n\t\t\t.then((res) => {\r\n\t\t\t\tthis.device.latencyTimer = new Uint8Array(res.data.buffer)[0];\r\n\t\t\t\t\r\n\t\t\t\t/*console.log(\"Current Latency Timer: \");\r\n\t\t\t\t\tconsole.log(this.device.latencyTimer);*/\r\n\r\n\t\t\t\tif (this.device.latencyTimer != 1) {\r\n\t\t\t\t\t/*console.log(\"Setting latency timer to 1\")*/\r\n\t\t\t\t\treturn this.device.controlTransferOut({\r\n\t\t\t\t\t\trequestType: 'vendor',\r\n\t\t\t\t\t\trecipient: \"device\",\r\n\t\t\t\t\t\trequest: this.#FTDI_SIO_SET_LATENCY_TIMER_REQUEST,\r\n\t\t\t\t\t\tvalue: 1,\r\n\t\t\t\t\t\tindex: 0\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\t.then((res) => {\r\n\t\t\t\treturn this.device.latencyTimer =   this.device.controlTransferIn({\r\n\t\t\t\t\trequestType: 'vendor',\r\n\t\t\t\t\trecipient: 'device',\r\n\t\t\t\t\trequest: this.#FTDI_SIO_GET_LATENCY_TIMER_REQUEST,\r\n\t\t\t\t\tvalue: 0,\r\n\t\t\t\t\tindex: 0\r\n\t\t\t\t},1);\r\n\r\n    \t\t    /*\tconsole.log(this.device.controlTransferOut({\r\n\t\t        'requestType': 'class',\r\n\t\t        'recipient': 'interface',\r\n\t\t        'request': 0x22,\r\n\t\t        'value': 0x01,\r\n\t\t        'index': this.interfaceNumber\r\n\t\t    \t}))*/\r\n\t\t    })\r\n\t\t    .then((res) => {\r\n\t\t\t\tthis.device.latencyTimer = new Uint8Array(res.data.buffer)[0];\r\n\t\t\t\t\r\n\t\t\t\tconsole.log(\"Current Latency Timer: \");\r\n\t\t\t\t\tconsole.log(this.device.latencyTimer);\r\n\t      \t\treadLoop();\r\n\t\t\t\treturn this.device;\r\n\t\t    });\r\n\t}\r\n\r\n \tDIV_ROUND_CLOSEST(x, divisor)\r\n\t{\t\t\t\t\t\t\t\r\n\t\tlet __x = x;\t\t\t\t\r\n\t\tlet __d = divisor;\t\t\t\r\n\t\treturn ((((x))-1) > 0 ||\t\t\t\t\r\n\t\t (((divisor))-1) > 0 ||\t\t\t\r\n\t\t (((__x) > 0) == ((__d) > 0))) ?\t\t\r\n\t\t\t(((__x) + ((__d) / 2)) / (__d)) :\t\r\n\t\t\t(((__x) - ((__d) / 2)) / (__d));\t\r\n\t}\t\t\t\t\t\t\t\r\n\t\r\n\tgetBaudBase() {\r\n\t\t// older devices = 12000000 ? \r\n\t\treturn 48000000;\r\n\t}\r\n\r\n\tgetBaudDivisor(baud) {\r\n/*\r\n\tworks for 232bm, 2232c, 232rl, ftx\r\n*/\r\n\r\n\t\tlet base = this.getBaudBase();\r\n\t\r\n\t//\tstatic const unsigned char divfrac[8] = { 0, 3, 2, 4, 1, 5, 6, 7 };\r\n\r\n\t\t// let divfrac = new Uint8Array(8);\r\n\t\tconst divfrac = [ 0, 3, 2, 4, 1, 5, 6, 7 ];\r\n\r\n\t\tlet divisor = 0;\r\n\r\n\t\tlet divisor3 = this.DIV_ROUND_CLOSEST(base, 2 * baud);\r\n\t\tdivisor = divisor3 >> 3;\r\n\t\tdivisor |= divfrac[divisor3 & 0x7] << 14;\r\n\t\t/* Deal with special cases for highest baud rates. */\r\n\t\tif (divisor == 1)\r\n\t\t\tdivisor = 0;\r\n\t\telse if (divisor == 0x4001)\r\n\t\t\tdivisor = 1;\r\n\t\treturn divisor;\r\n\r\n\t}\r\n\r\n\t/* The SIO requires the first byte to have:\r\n\t *  B0 1\r\n\t *  B1 0\r\n\t *  B2..7 length of message excluding byte 0\r\n\t *\r\n\t * The new devices do not require this byte\r\n\t */\r\n\r\n\tsend(data) {\r\n\t\treturn this.device.transferOut(this.endpointOut, data);\r\n\t}\r\n\r\n\tdisconnect() {\r\n\t\t/*return console.log(this.device.controlTransferOut({\r\n\t\t        'requestType': 'class',\r\n\t\t        'recipient': 'interface',\r\n\t\t        'request': 0x22,\r\n\t\t        'value': 0x01,\r\n\t\t        'index': this.interfaceNumber\r\n\t\t    \t}).then(()=>\r\n\t\t this.device.close()))*/\r\n\t\t this.device.close();\r\n\t}\r\n}\r\n\r\nexport class WebUSBSerialDevice {\r\n    // devices: any[];\r\n    // configuration: any;\r\n\r\n\tconstructor(configuration) {\r\n\t\tif (!('usb' in navigator)) {\r\n\t\t\tthrow new Error('USB Support not available!');\r\n\t\t}\r\n\r\n\t\tthis.configuration = configuration || {\r\n\t\t\t// Whether or not to override/specify baud/bits/stop/parity\r\n\t\t\toverridePortSettings: false,\r\n\t\t\t\r\n\t\t\t// Default settings, only used when overridden\r\n\t\t\tbaudrate: 9600,\r\n\t\t\tbits: 8,\r\n\t\t\tstop: 1,\r\n\t\t\tparity: false,\r\n\r\n\t\t\t// Some default FTDI device IDs\r\n\t\t\t// you can replace these with any device that has\r\n\t\t\t// an ftdi chip.\r\n\t\t\tdeviceFilters: [\r\n\t\t\t\t/*{ 'vendorId' : 0x0403, 'productId' : 0x6000 },\r\n\t\t\t\t{ 'vendorId' : 0x0403, 'productId' : 0x6001 },\r\n\t\t\t\t{ 'vendorId' : 0x0403, 'productId' : 0x6010 },\r\n\t\t\t\t{ 'vendorId' : 0x0403, 'productId' : 0x6011 },\r\n\t\t\t\t{ 'vendorId' : 0x0403, 'productId' : 0x6014 }*/\r\n\t\t\t]\r\n\t\t}\r\n\r\n\t\tthis.devices = [];\r\n\t\t//this.ports = [];\r\n\t}\r\n\r\n\tasync getAvailablePorts() {\r\n\t    this.devices = await navigator.usb.getDevices();\r\n\r\n    \treturn this.devices.map(device => new WebUSBSerialPort(device));\r\n\t}\r\n\r\n\tasync requestNewPort() {\r\n\t\ttry {\r\n\t\t\tlet device = await navigator.usb.requestDevice({\r\n\t\t\t\tfilters : this.configuration.deviceFilters || []\r\n\t\t\t});\r\n\r\n\t\t\tif (!(device in this.devices))\r\n\t\t\t\tthis.devices.push(device);\r\n\r\n\t\t\treturn new WebUSBSerialPort(device);\r\n\t\t} catch (e) {\r\n\t\t\tthrow new Error(e);\r\n\t\t}\r\n\t}\r\n\r\n}","\r\nimport { serial as serialPolyfill } from 'web-serial-polyfill';\r\nimport { WebUSBSerialDevice } from './ftdi';\r\n\r\nasync function runUSB() {\r\n    const out = document.getElementById('outUSB');\r\n    try {\r\n      const device = await navigator.usb.requestDevice({ filters: [] });\r\n      out.innerHTML = [\r\n        'productName',\r\n        'deviceClass',\r\n        'deviceSubclass',\r\n        'deviceProtocol',\r\n      ].map(k => k + ': ' + device[k]).join('\\n');\r\n    }\r\n    catch (e) {\r\n      out.innerHTML = e.message;\r\n    }\r\n}\r\n\r\n\r\n\r\nlet cleanupSerial = null;\r\nasync function runSerial() {\r\n    if (cleanupSerial) {\r\n        cleanupSerial();\r\n        cleanupSerial = null;\r\n    }\r\n    const out = document.getElementById('outSerial');\r\n    try {\r\n        out.innerHTML = '';\r\n        let serial = serialPolyfill;\r\n        \r\n        if (navigator.serial) {\r\n            serial = navigator.serial;\r\n            out.innerHTML += '\\nWeb Serial API supported. Polyfill not used.'\r\n        }\r\n\r\n        const port = await serial.requestPort();\r\n        out.innerHTML = [\r\n            'usbVendorId',\r\n            'usbProductId',\r\n          ].map(k => k + ': ' + port[k]).join('\\n');\r\n\r\n        const form = document.getElementById('serial-open');\r\n        const openButton = document.getElementById('serialOpen');\r\n        form.style.display = 'block';\r\n        const openPort = async () => {\r\n            try {\r\n                const serialOptions = {\r\n                    baudRate: +document.getElementById('baudRate').value,\r\n                    dataBits: +document.getElementById('dataBits').value,\r\n                    stopBits: +document.getElementById('stopBits').value,\r\n                    parity: document.getElementById('parity').value,\r\n                };\r\n                console.log(serialOptions);\r\n                await port.open(serialOptions);\r\n                out.innerHTML += '\\nopened';\r\n            }\r\n            catch (e) {\r\n                out.innerHTML = e.message;\r\n            }\r\n        };\r\n        openButton.addEventListener('click', openPort);\r\n        cleanupSerial = () => {\r\n            cleanupSerial && cleanupSerial();\r\n            openButton.removeEventListener('click', openPort);\r\n        };\r\n    }\r\n    catch (e) {\r\n      out.innerHTML = e.message;\r\n    }\r\n}\r\n\r\n\r\nlet ftdiPort;\r\nasync function runFTDI() {\r\n    const out = document.getElementById('outFTDI');\r\n    \r\n    try {\r\n        out.innerHTML = '';\r\n        const device = new WebUSBSerialDevice({\r\n            overridePortSettings: true,\r\n            // these are the defaults, this config is only used if above is true\r\n            baud: 19200,\r\n            bits: 8,\r\n            stop: 1,\r\n            parity: false\r\n        });\r\n        // shows browser request for usb device\r\n        const port = ftdiPort = await device.requestNewPort();\r\n\r\n        await port.connect(data => {\r\n            out.innerHTML += 'Rec: ' + data.join(', ') + '\\n';\r\n        });\r\n\r\n        let send = async () => {\r\n            out.innerHTML += 'Send 1, 3, 0, 52, 0, 1, 197, 196\\n'\r\n            const data = new Uint8Array([1, 3, 0, 52, 0, 1, 197, 196 ]);\r\n            await port.send(data);\r\n            setTimeout(send, 5000);\r\n        }\r\n        send();\r\n    }\r\n    catch (e) {\r\n      out.innerHTML = e.message;\r\n    }\r\n}\r\n\r\ndocument.getElementById('requestUSB').addEventListener('click', runUSB);\r\ndocument.getElementById('requestSerial').addEventListener('click', runSerial);\r\ndocument.getElementById('requestFTDI').addEventListener('click', runFTDI);\r\n"],"names":["$55a31c8eb06014ca$var$SerialPolyfillProtocol","SerialPolyfillProtocol","$55a31c8eb06014ca$exports","$55a31c8eb06014ca$var$kAcceptableDataBits","$55a31c8eb06014ca$var$kAcceptableStopBits","$55a31c8eb06014ca$var$kAcceptableParity","$55a31c8eb06014ca$var$kParityIndexMapping","$55a31c8eb06014ca$var$kStopBitsIndexMapping","$55a31c8eb06014ca$var$kDefaultPolyfillOptions","protocol","UsbCdcAcm","usbControlInterfaceClass","usbTransferInterfaceClass","$55a31c8eb06014ca$var$findInterface","device","classCode","configuration","configurations","iface","interfaces","alternates","interfaceClass","TypeError","$55a31c8eb06014ca$var$findEndpoint","direction","alternate","endpoint","endpoints","interfaceNumber","$55a31c8eb06014ca$var$UsbEndpointUnderlyingSource","constructor","onError","this","type","device_","endpoint_","onError_","pull","controller","chunkSize","desiredSize","d","packetSize","Math","ceil","result","transferIn","endpointNumber","status","error","_a","data","buffer","chunk","Uint8Array","byteOffset","byteLength","enqueue","toString","$55a31c8eb06014ca$var$UsbEndpointUnderlyingSink","async","transferOut","$55a31c8eb06014ca$var$SerialPort","polyfillOptions","polyfillOptions_","Object","assign","outputSignals_","dataTerminalReady","requestToSend","break","controlInterface_","transferInterface_","inEndpoint_","outEndpoint_","readable","readable_","opened","ReadableStream","highWaterMark","serialOptions_","bufferSize","writable","writable_","WritableStream","ByteLengthQueuingStrategy","options","validateOptions","open","selectConfiguration","claimInterface","setLineCoding","setSignals","close","Error","promises","push","cancel","abort","Promise","all","forget","getInfo","usbVendorId","vendorId","usbProductId","productId","reconfigure","signals","undefined","value","controlTransferOut","requestType","recipient","request","index","value1","isValidBaudRate","baudRate","RangeError","isValidDataBits","dataBits","isValidStopBits","stopBits","isValidParity","parity","includes","ArrayBuffer","view","DataView","setUint32","setUint8","indexOf","_b","_c","DOMException","SerialPort","serial","usbFilters","filters","filter","usbFilter","length","navigator","usb","requestDevice","devices","getDevices","ports","forEach","port","e","$08707fe144621b8e$var$WebUSBSerialPort","FTDI_SIO_RESET","FTDI_SIO_MODEM_CTRL","FTDI_SIO_SET_FLOW_CTRL","FTDI_SIO_SET_BAUD_RATE","FTDI_SIO_SET_DATA","FTDI_SIO_GET_MODEM_STATUS","FTDI_SIO_SET_EVENT_CHAR","FTDI_SIO_SET_ERROR_CHAR","FTDI_BitMode_Reset","FTDI_BitMode_Opto","INTERFACE_A","PIT_DEFAULT","PIT_SIOB","FTDI_SIO_RESET_REQUEST","FTDI_SIO_RESET_REQUEST_TYPE","FTDI_SIO_RESET_SIO","FTDI_SIO_RESET_PURGE_RX","FTDI_SIO_RESET_PURGE_TX","FTDI_SIO_SET_BAUDRATE_REQUEST","ftdi_chip_type","SIO","FT8U232AM","FT232BM","FT2232C","FT232RL","FT2232H","FT4232H","FT232H","FTX","FTDI_SIO_SET_DTR_MASK","FTDI_SIO_SET_DTR_HIGH","FTDI_SIO_SET_RTS_MASK","FTDI_SIO_GET_LATENCY_TIMER","$35da740d59af89ba$var$ftdiPort","$35da740d59af89ba$var$cleanupSerial","document","getElementById","addEventListener","out","innerHTML","map","k","join","message","requestPort","form","openButton","style","display","openPort","serialOptions","console","log","removeEventListener","$08707fe144621b8e$export$d77a38932c9515af","overridePortSettings","baud","bits","stop","requestNewPort","connect","send","setTimeout"],"version":3,"file":"index.71da80f7.js.map"}