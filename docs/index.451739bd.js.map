{"mappings":"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","sources":["node_modules/web-serial-polyfill/serial.ts","src/index.js"],"sourcesContent":["/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of\n * the License at\n *\n *    https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in\n * writing, software distributed under the License is\n * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES\n * OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing\n * permissions and limitations under the License.\n */\n'use strict';\n\nexport enum SerialPolyfillProtocol {\n  UsbCdcAcm, // eslint-disable-line no-unused-vars\n}\n\nexport interface SerialPolyfillOptions {\n  protocol?: SerialPolyfillProtocol;\n  usbControlInterfaceClass?: number;\n  usbTransferInterfaceClass?: number;\n}\n\nconst kSetLineCoding = 0x20;\nconst kSetControlLineState = 0x22;\nconst kSendBreak = 0x23;\n\nconst kDefaultBufferSize = 255;\nconst kDefaultDataBits = 8;\nconst kDefaultParity = 'none';\nconst kDefaultStopBits = 1;\n\nconst kAcceptableDataBits = [16, 8, 7, 6, 5];\nconst kAcceptableStopBits = [1, 2];\nconst kAcceptableParity = ['none', 'even', 'odd'];\n\nconst kParityIndexMapping: ParityType[] =\n    ['none', 'odd', 'even'];\nconst kStopBitsIndexMapping = [1, 1.5, 2];\n\nconst kDefaultPolyfillOptions = {\n  protocol: SerialPolyfillProtocol.UsbCdcAcm,\n  usbControlInterfaceClass: 2,\n  usbTransferInterfaceClass: 10,\n};\n\n/**\n * Utility function to get the interface implementing a desired class.\n * @param {USBDevice} device The USB device.\n * @param {number} classCode The desired interface class.\n * @return {USBInterface} The first interface found that implements the desired\n * class.\n * @throws TypeError if no interface is found.\n */\nfunction findInterface(device: USBDevice, classCode: number): USBInterface {\n  const configuration = device.configurations[0];\n  for (const iface of configuration.interfaces) {\n    const alternate = iface.alternates[0];\n    if (alternate.interfaceClass === classCode) {\n      return iface;\n    }\n  }\n  throw new TypeError(`Unable to find interface with class ${classCode}.`);\n}\n\n/**\n * Utility function to get an endpoint with a particular direction.\n * @param {USBInterface} iface The interface to search.\n * @param {USBDirection} direction The desired transfer direction.\n * @return {USBEndpoint} The first endpoint with the desired transfer direction.\n * @throws TypeError if no endpoint is found.\n */\nfunction findEndpoint(iface: USBInterface, direction: USBDirection):\n    USBEndpoint {\n  const alternate = iface.alternates[0];\n  for (const endpoint of alternate.endpoints) {\n    if (endpoint.direction == direction) {\n      return endpoint;\n    }\n  }\n  throw new TypeError(`Interface ${iface.interfaceNumber} does not have an ` +\n                      `${direction} endpoint.`);\n}\n\n/**\n * Implementation of the underlying source API[1] which reads data from a USB\n * endpoint. This can be used to construct a ReadableStream.\n *\n * [1]: https://streams.spec.whatwg.org/#underlying-source-api\n */\nclass UsbEndpointUnderlyingSource implements UnderlyingByteSource {\n  private device_: USBDevice;\n  private endpoint_: USBEndpoint;\n  private onError_: () => void;\n\n  type: 'bytes';\n\n  /**\n   * Constructs a new UnderlyingSource that will pull data from the specified\n   * endpoint on the given USB device.\n   *\n   * @param {USBDevice} device\n   * @param {USBEndpoint} endpoint\n   * @param {function} onError function to be called on error\n   */\n  constructor(device: USBDevice, endpoint: USBEndpoint, onError: () => void) {\n    this.type = 'bytes';\n    this.device_ = device;\n    this.endpoint_ = endpoint;\n    this.onError_ = onError;\n  }\n\n  /**\n   * Reads a chunk of data from the device.\n   *\n   * @param {ReadableByteStreamController} controller\n   */\n  pull(controller: ReadableByteStreamController): void {\n    (async (): Promise<void> => {\n      let chunkSize;\n      if (controller.desiredSize) {\n        const d = controller.desiredSize / this.endpoint_.packetSize;\n        chunkSize = Math.ceil(d) * this.endpoint_.packetSize;\n      } else {\n        chunkSize = this.endpoint_.packetSize;\n      }\n\n      try {\n        const result = await this.device_.transferIn(\n            this.endpoint_.endpointNumber, chunkSize);\n        if (result.status != 'ok') {\n          controller.error(`USB error: ${result.status}`);\n          this.onError_();\n        }\n        if (result.data?.buffer) {\n          const chunk = new Uint8Array(\n              result.data.buffer, result.data.byteOffset,\n              result.data.byteLength);\n          controller.enqueue(chunk);\n        }\n      } catch (error) {\n        controller.error(error.toString());\n        this.onError_();\n      }\n    })();\n  }\n}\n\n/**\n * Implementation of the underlying sink API[2] which writes data to a USB\n * endpoint. This can be used to construct a WritableStream.\n *\n * [2]: https://streams.spec.whatwg.org/#underlying-sink-api\n */\nclass UsbEndpointUnderlyingSink implements UnderlyingSink<Uint8Array> {\n  private device_: USBDevice;\n  private endpoint_: USBEndpoint;\n  private onError_: () => void;\n\n  /**\n   * Constructs a new UnderlyingSink that will write data to the specified\n   * endpoint on the given USB device.\n   *\n   * @param {USBDevice} device\n   * @param {USBEndpoint} endpoint\n   * @param {function} onError function to be called on error\n   */\n  constructor(device: USBDevice, endpoint: USBEndpoint, onError: () => void) {\n    this.device_ = device;\n    this.endpoint_ = endpoint;\n    this.onError_ = onError;\n  }\n\n  /**\n   * Writes a chunk to the device.\n   *\n   * @param {Uint8Array} chunk\n   * @param {WritableStreamDefaultController} controller\n   */\n  async write(\n      chunk: Uint8Array,\n      controller: WritableStreamDefaultController): Promise<void> {\n    try {\n      const result =\n          await this.device_.transferOut(this.endpoint_.endpointNumber, chunk);\n      if (result.status != 'ok') {\n        controller.error(result.status);\n        this.onError_();\n      }\n    } catch (error) {\n      controller.error(error.toString());\n      this.onError_();\n    }\n  }\n}\n\n/** a class used to control serial devices over WebUSB */\nexport class SerialPort {\n  private polyfillOptions_: SerialPolyfillOptions;\n  private device_: USBDevice;\n  private controlInterface_: USBInterface;\n  private transferInterface_: USBInterface;\n  private inEndpoint_: USBEndpoint;\n  private outEndpoint_: USBEndpoint;\n\n  private serialOptions_: SerialOptions;\n  private readable_: ReadableStream<Uint8Array> | null;\n  private writable_: WritableStream<Uint8Array> | null;\n  private outputSignals_: SerialOutputSignals;\n\n  /**\n   * constructor taking a WebUSB device that creates a SerialPort instance.\n   * @param {USBDevice} device A device acquired from the WebUSB API\n   * @param {SerialPolyfillOptions} polyfillOptions Optional options to\n   * configure the polyfill.\n   */\n  public constructor(\n      device: USBDevice,\n      polyfillOptions?: SerialPolyfillOptions) {\n    this.polyfillOptions_ = {...kDefaultPolyfillOptions, ...polyfillOptions};\n    this.outputSignals_ = {\n      dataTerminalReady: false,\n      requestToSend: false,\n      break: false,\n    };\n\n    this.device_ = device;\n    this.controlInterface_ = findInterface(\n        this.device_,\n        this.polyfillOptions_.usbControlInterfaceClass as number);\n    this.transferInterface_ = findInterface(\n        this.device_,\n        this.polyfillOptions_.usbTransferInterfaceClass as number);\n    this.inEndpoint_ = findEndpoint(this.transferInterface_, 'in');\n    this.outEndpoint_ = findEndpoint(this.transferInterface_, 'out');\n  }\n\n  /**\n   * Getter for the readable attribute. Constructs a new ReadableStream as\n   * necessary.\n   * @return {ReadableStream} the current readable stream\n   */\n  public get readable(): ReadableStream<Uint8Array> | null {\n    if (!this.readable_ && this.device_.opened) {\n      this.readable_ = new ReadableStream<Uint8Array>(\n          new UsbEndpointUnderlyingSource(\n              this.device_, this.inEndpoint_, () => {\n                this.readable_ = null;\n              }),\n          {\n            highWaterMark: this.serialOptions_.bufferSize ?? kDefaultBufferSize,\n          });\n    }\n    return this.readable_;\n  }\n\n  /**\n   * Getter for the writable attribute. Constructs a new WritableStream as\n   * necessary.\n   * @return {WritableStream} the current writable stream\n   */\n  public get writable(): WritableStream<Uint8Array> | null {\n    if (!this.writable_ && this.device_.opened) {\n      this.writable_ = new WritableStream(\n          new UsbEndpointUnderlyingSink(\n              this.device_, this.outEndpoint_, () => {\n                this.writable_ = null;\n              }),\n          new ByteLengthQueuingStrategy({\n            highWaterMark: this.serialOptions_.bufferSize ?? kDefaultBufferSize,\n          }));\n    }\n    return this.writable_;\n  }\n\n  /**\n   * a function that opens the device and claims all interfaces needed to\n   * control and communicate to and from the serial device\n   * @param {SerialOptions} options Object containing serial options\n   * @return {Promise<void>} A promise that will resolve when device is ready\n   * for communication\n   */\n  public async open(options: SerialOptions): Promise<void> {\n    this.serialOptions_ = options;\n    this.validateOptions();\n\n    try {\n      await this.device_.open();\n      if (this.device_.configuration === null) {\n        await this.device_.selectConfiguration(1);\n      }\n\n      await this.device_.claimInterface(this.controlInterface_.interfaceNumber);\n      if (this.controlInterface_ !== this.transferInterface_) {\n        await this.device_.claimInterface(\n            this.transferInterface_.interfaceNumber);\n      }\n\n      await this.setLineCoding();\n      await this.setSignals({dataTerminalReady: true});\n    } catch (error) {\n      if (this.device_.opened) {\n        await this.device_.close();\n      }\n      throw new Error('Error setting up device: ' + error.toString());\n    }\n  }\n\n  /**\n   * Closes the port.\n   *\n   * @return {Promise<void>} A promise that will resolve when the port is\n   * closed.\n   */\n  public async close(): Promise<void> {\n    const promises = [];\n    if (this.readable_) {\n      promises.push(this.readable_.cancel());\n    }\n    if (this.writable_) {\n      promises.push(this.writable_.abort());\n    }\n    await Promise.all(promises);\n    this.readable_ = null;\n    this.writable_ = null;\n    if (this.device_.opened) {\n      await this.setSignals({dataTerminalReady: false, requestToSend: false});\n      await this.device_.close();\n    }\n  }\n\n  /**\n   * Forgets the port.\n   *\n   * @return {Promise<void>} A promise that will resolve when the port is\n   * forgotten.\n   */\n  public async forget(): Promise<void> {\n    return this.device_.forget();\n  }\n\n  /**\n   * A function that returns properties of the device.\n   * @return {SerialPortInfo} Device properties.\n   */\n  public getInfo(): SerialPortInfo {\n    return {\n      usbVendorId: this.device_.vendorId,\n      usbProductId: this.device_.productId,\n    };\n  }\n\n  /**\n   * A function used to change the serial settings of the device\n   * @param {object} options the object which carries serial settings data\n   * @return {Promise<void>} A promise that will resolve when the options are\n   * set\n   */\n  public reconfigure(options: SerialOptions): Promise<void> {\n    this.serialOptions_ = {...this.serialOptions_, ...options};\n    this.validateOptions();\n    return this.setLineCoding();\n  }\n\n  /**\n   * Sets control signal state for the port.\n   * @param {SerialOutputSignals} signals The signals to enable or disable.\n   * @return {Promise<void>} a promise that is resolved when the signal state\n   * has been changed.\n   */\n  public async setSignals(signals: SerialOutputSignals): Promise<void> {\n    this.outputSignals_ = {...this.outputSignals_, ...signals};\n\n    if (signals.dataTerminalReady !== undefined ||\n        signals.requestToSend !== undefined) {\n      // The Set_Control_Line_State command expects a bitmap containing the\n      // values of all output signals that should be enabled or disabled.\n      //\n      // Ref: USB CDC specification version 1.1 §6.2.14.\n      const value = (this.outputSignals_.dataTerminalReady ? 1 << 0 : 0) |\n                    (this.outputSignals_.requestToSend ? 1 << 1 : 0);\n\n      await this.device_.controlTransferOut({\n        'requestType': 'class',\n        'recipient': 'interface',\n        'request': kSetControlLineState,\n        'value': value,\n        'index': this.controlInterface_.interfaceNumber,\n      });\n    }\n\n    if (signals.break !== undefined) {\n      // The SendBreak command expects to be given a duration for how long the\n      // break signal should be asserted. Passing 0xFFFF enables the signal\n      // until 0x0000 is send.\n      //\n      // Ref: USB CDC specification version 1.1 §6.2.15.\n      const value = this.outputSignals_.break ? 0xFFFF : 0x0000;\n\n      await this.device_.controlTransferOut({\n        'requestType': 'class',\n        'recipient': 'interface',\n        'request': kSendBreak,\n        'value': value,\n        'index': this.controlInterface_.interfaceNumber,\n      });\n    }\n  }\n\n  /**\n   * Checks the serial options for validity and throws an error if it is\n   * not valid\n   */\n  private validateOptions(): void {\n    if (!this.isValidBaudRate(this.serialOptions_.baudRate)) {\n      throw new RangeError('invalid Baud Rate ' + this.serialOptions_.baudRate);\n    }\n\n    if (!this.isValidDataBits(this.serialOptions_.dataBits)) {\n      throw new RangeError('invalid dataBits ' + this.serialOptions_.dataBits);\n    }\n\n    if (!this.isValidStopBits(this.serialOptions_.stopBits)) {\n      throw new RangeError('invalid stopBits ' + this.serialOptions_.stopBits);\n    }\n\n    if (!this.isValidParity(this.serialOptions_.parity)) {\n      throw new RangeError('invalid parity ' + this.serialOptions_.parity);\n    }\n  }\n\n  /**\n   * Checks the baud rate for validity\n   * @param {number} baudRate the baud rate to check\n   * @return {boolean} A boolean that reflects whether the baud rate is valid\n   */\n  private isValidBaudRate(baudRate: number): boolean {\n    return baudRate % 1 === 0;\n  }\n\n  /**\n   * Checks the data bits for validity\n   * @param {number} dataBits the data bits to check\n   * @return {boolean} A boolean that reflects whether the data bits setting is\n   * valid\n   */\n  private isValidDataBits(dataBits: number | undefined): boolean {\n    if (typeof dataBits === 'undefined') {\n      return true;\n    }\n    return kAcceptableDataBits.includes(dataBits);\n  }\n\n  /**\n   * Checks the stop bits for validity\n   * @param {number} stopBits the stop bits to check\n   * @return {boolean} A boolean that reflects whether the stop bits setting is\n   * valid\n   */\n  private isValidStopBits(stopBits: number | undefined): boolean {\n    if (typeof stopBits === 'undefined') {\n      return true;\n    }\n    return kAcceptableStopBits.includes(stopBits);\n  }\n\n  /**\n   * Checks the parity for validity\n   * @param {string} parity the parity to check\n   * @return {boolean} A boolean that reflects whether the parity is valid\n   */\n  private isValidParity(parity: ParityType | undefined): boolean {\n    if (typeof parity === 'undefined') {\n      return true;\n    }\n    return kAcceptableParity.includes(parity);\n  }\n\n  /**\n   * sends the options alog the control interface to set them on the device\n   * @return {Promise} a promise that will resolve when the options are set\n   */\n  private async setLineCoding(): Promise<void> {\n    // Ref: USB CDC specification version 1.1 §6.2.12.\n    const buffer = new ArrayBuffer(7);\n    const view = new DataView(buffer);\n    view.setUint32(0, this.serialOptions_.baudRate, true);\n    view.setUint8(\n        4, kStopBitsIndexMapping.indexOf(\n            this.serialOptions_.stopBits ?? kDefaultStopBits));\n    view.setUint8(\n        5, kParityIndexMapping.indexOf(\n            this.serialOptions_.parity ?? kDefaultParity));\n    view.setUint8(6, this.serialOptions_.dataBits ?? kDefaultDataBits);\n\n    const result = await this.device_.controlTransferOut({\n      'requestType': 'class',\n      'recipient': 'interface',\n      'request': kSetLineCoding,\n      'value': 0x00,\n      'index': this.controlInterface_.interfaceNumber,\n    }, buffer);\n    if (result.status != 'ok') {\n      throw new DOMException('NetworkError', 'Failed to set line coding.');\n    }\n  }\n}\n\n/** implementation of the global navigator.serial object */\nclass Serial {\n  /**\n   * Requests permission to access a new port.\n   *\n   * @param {SerialPortRequestOptions} options\n   * @param {SerialPolyfillOptions} polyfillOptions\n   * @return {Promise<SerialPort>}\n   */\n  async requestPort(\n      options?: SerialPortRequestOptions,\n      polyfillOptions?: SerialPolyfillOptions): Promise<SerialPort> {\n    polyfillOptions = {...kDefaultPolyfillOptions, ...polyfillOptions};\n\n    const usbFilters: USBDeviceFilter[] = [];\n    if (options && options.filters) {\n      for (const filter of options.filters) {\n        const usbFilter: USBDeviceFilter = {\n          classCode: polyfillOptions.usbControlInterfaceClass,\n        };\n        if (filter.usbVendorId !== undefined) {\n          usbFilter.vendorId = filter.usbVendorId;\n        }\n        if (filter.usbProductId !== undefined) {\n          usbFilter.productId = filter.usbProductId;\n        }\n        usbFilters.push(usbFilter);\n      }\n    }\n\n    if (usbFilters.length === 0) {\n      usbFilters.push({\n        classCode: polyfillOptions.usbControlInterfaceClass,\n      });\n    }\n\n    const device = await navigator.usb.requestDevice({'filters': usbFilters});\n    const port = new SerialPort(device, polyfillOptions);\n    return port;\n  }\n\n  /**\n   * Get the set of currently available ports.\n   *\n   * @param {SerialPolyfillOptions} polyfillOptions Polyfill configuration that\n   * should be applied to these ports.\n   * @return {Promise<SerialPort[]>} a promise that is resolved with a list of\n   * ports.\n   */\n  async getPorts(polyfillOptions?: SerialPolyfillOptions):\n      Promise<SerialPort[]> {\n    polyfillOptions = {...kDefaultPolyfillOptions, ...polyfillOptions};\n\n    const devices = await navigator.usb.getDevices();\n    const ports: SerialPort[] = [];\n    devices.forEach((device) => {\n      try {\n        const port = new SerialPort(device, polyfillOptions);\n        ports.push(port);\n      } catch (e) {\n        // Skip unrecognized port.\n      }\n    });\n    return ports;\n  }\n}\n\n/* an object to be used for starting the serial workflow */\nexport const serial = new Serial();\n","\r\nimport serialPolyfill from 'web-serial-polyfill';\r\n\r\nasync function runUSB() {\r\n    const out = document.getElementById('outUSB');\r\n    try {\r\n      const device = await navigator.usb.requestDevice({ filters: [] });\r\n      out.innerHTML = [\r\n        'productName',\r\n        'deviceClass',\r\n        'deviceSubclass',\r\n        'deviceProtocol',\r\n      ].map(k => k + ': ' + device[k]).join('\\n');\r\n    }\r\n    catch (e) {\r\n      out.innerHTML = e.message;\r\n    }\r\n}\r\n\r\n\r\n\r\nlet cleanupSerial = null;\r\nasync function runSerial() {\r\n    if (cleanupSerial) {\r\n        cleanupSerial();\r\n        cleanupSerial = null;\r\n    }\r\n    const out = document.getElementById('outSerial');\r\n    try {\r\n        out.innerHTML = '';\r\n        let serial = serialPolyfill;\r\n        if (navigator.serial) {\r\n            serial = navigator.serial;\r\n            out.innerHTML += '\\nWeb Serial API supported. Polyfill not used.'\r\n        }\r\n\r\n        const port = await serial.requestPort();\r\n        out.innerHTML = [\r\n            'usbVendorId',\r\n            'usbProductId',\r\n          ].map(k => k + ': ' + port[k]).join('\\n');\r\n\r\n        const form = document.getElementById('serial-open');\r\n        const openButton = document.getElementById('serialOpen');\r\n        form.style.display = 'block';\r\n        const openPort = async () => {\r\n            try {\r\n                const serialOptions = {\r\n                    baudRate: +document.getElementById('baudRate').value,\r\n                    dataBits: +document.getElementById('dataBits').value,\r\n                    stopBits: +document.getElementById('stopBits').value,\r\n                    parity: document.getElementById('parity').value,\r\n                };\r\n                console.log(serialOptions);\r\n                await port.open(serialOptions);\r\n                out.innerHTML += '\\nopened';\r\n            }\r\n            catch (e) {\r\n                out.innerHTML = e.message;\r\n            }\r\n        };\r\n        openButton.addEventListener('click', openPort);\r\n        cleanupSerial = () => {\r\n            cleanupSerial && cleanupSerial();\r\n            openButton.removeEventListener('click', openPort);\r\n        };\r\n    }\r\n    catch (e) {\r\n      out.innerHTML = e.message;\r\n    }\r\n}\r\n\r\ndocument.getElementById('requestUSB').addEventListener('click', runUSB);\r\ndocument.getElementById('requestSerial').addEventListener('click', runSerial);\r\n"],"names":["$55a31c8eb06014ca$var$SerialPolyfillProtocol","SerialPolyfillProtocol","$55a31c8eb06014ca$exports","$55a31c8eb06014ca$var$kAcceptableDataBits","$55a31c8eb06014ca$var$kAcceptableStopBits","$55a31c8eb06014ca$var$kAcceptableParity","$55a31c8eb06014ca$var$kParityIndexMapping","$55a31c8eb06014ca$var$kStopBitsIndexMapping","$55a31c8eb06014ca$var$kDefaultPolyfillOptions","protocol","UsbCdcAcm","usbControlInterfaceClass","usbTransferInterfaceClass","$55a31c8eb06014ca$var$findInterface","device","classCode","configuration","configurations","iface","interfaces","alternates","interfaceClass","TypeError","$55a31c8eb06014ca$var$findEndpoint","direction","alternate","endpoint","endpoints","interfaceNumber","$55a31c8eb06014ca$var$UsbEndpointUnderlyingSource","constructor","onError","this","type","device_","endpoint_","onError_","pull","controller","chunkSize","desiredSize","d","packetSize","Math","ceil","result","transferIn","endpointNumber","status","error","_a","data","buffer","chunk","Uint8Array","byteOffset","byteLength","enqueue","toString","$55a31c8eb06014ca$var$UsbEndpointUnderlyingSink","async","transferOut","$55a31c8eb06014ca$var$SerialPort","polyfillOptions","polyfillOptions_","Object","assign","outputSignals_","dataTerminalReady","requestToSend","break","controlInterface_","transferInterface_","inEndpoint_","outEndpoint_","readable","readable_","opened","ReadableStream","highWaterMark","serialOptions_","bufferSize","writable","writable_","WritableStream","ByteLengthQueuingStrategy","options","validateOptions","open","selectConfiguration","claimInterface","setLineCoding","setSignals","close","Error","promises","push","cancel","abort","Promise","all","forget","getInfo","usbVendorId","vendorId","usbProductId","productId","reconfigure","signals","undefined","value","controlTransferOut","requestType","recipient","request","index","value1","isValidBaudRate","baudRate","RangeError","isValidDataBits","dataBits","isValidStopBits","stopBits","isValidParity","parity","includes","ArrayBuffer","view","DataView","setUint32","setUint8","indexOf","_b","_c","DOMException","SerialPort","serial","usbFilters","filters","filter","usbFilter","length","navigator","usb","requestDevice","devices","getDevices","ports","forEach","port","e","$35da740d59af89ba$var$cleanupSerial","document","getElementById","addEventListener","out","innerHTML","map","k","join","message","$parcel$interopDefault","requestPort","form","openButton","style","display","openPort","serialOptions","console","log","removeEventListener"],"version":3,"file":"index.451739bd.js.map"}